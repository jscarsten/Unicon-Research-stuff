Questions
	
Is icode the icon equivalent to bytecode? If so how is it different to say java bytecode that runs on JVM

Need some clarification about the null value descriptor representation. Is the n flag set? Is it just empty?

Are qualifiers treated as descriptors in blocks?
If yes then ... -->
So the location for the first descriptor in a block of a given type is supposed to be the same for all blocks with that type, but with records, there may be any number of non-descriptor qualifiers that point to strings that appear before the "descriptor". In this case are qualifiers 

The book says that Block-Pointers can be placed anywhere before the descriptors but they must be in the same place for all blocks of that type. What does a block pointer point to?

Is RTL an outside resource or is it developed custom for Icon

Icon List position access. I want some clarification about how this works. So I beleive that first the list positional access RTL code is run and it returns a variable descriptor that points to the address of the top of the block and accesses the element through an offset. I think the way the RTL code works is that it links through the LE block slots until it finds the correct element. If this is right then list positional access is not efficient like array positional access is. It is similar to linked list access which is O(n)

Is there support for multi-dimensional unicon arrays?

Sets have a number of segments in the set-header block which contain increasing numbers of slots which each contain it's own linked list header node. So the slot number the value is inserted into is calculated by taking the remainder from dividing the hash value from the number of slots. At which point it will be inserted by order of hash number into that slot's linked list (which might be empty). How is lookup performed in this scheme. Is it by calculating the hash value of the lookup value and checking to see if it's in that slot? What is the purpose of the segments? Why do the segments grow in size?. I am unsure why it helps performance. Also isn't it a lot of space to allocate for 1 structure?

Notes for Icon/Unicon implementation textbook

Preface
	- multiple compilers
		- icont/iconc
			- these are compilers that usuers use to traslate unicon code into machine 
			  code
				- iconc breaks icon code down to C code
				- icont breaks icon code down to virtaul machine code
			- a preprocessor called unicon translates unicon code into icon code which 
			  then compiles using iconc/
			- "unicon" is written in unicon
		- iconx
			- iconx is the name of the Unicon/Icon virtual machine
			- consists of a collection of high-level data-structure and I/O facilites,
			  which are built in to icon/unicon
		- rt.a
			- the runtime  library that is linked to Icon programs compiled with iconc
			- shared much of the code with iconx

Introduction
	- Implementing Programming Languages
		- in conventional programming languages most of the operations that are
		  performed upon execution can be determined statically by examining the code beforehand
		- also, most programming languages' operations closely correspond to the 
		  architecture of the computers on which they are executed
		- when these two conditions are met it is easy to map source code instructions 
		  to machine instructions for the computer to execute
		- this translation process is called compilation
		- in addition to a compiler most language implemetations include a run-time
		  component that contains subroutines for performing computations that are too complex to compile in-line, such as I/O and mathematical fucntions
		- some languages have features whose meanings change during program execution.
			- this makes these features unable to be determined statically from the 
  			  text of a source-language program 
  			- examples of these features are
  				- changing of fucntion meanings during execution
  				- creation of new data types at run-time
  				- self-modifying programs
  		- also some languages have features that do not match up with the architecture
  		  of conventional computers such as pattern matching
  		- in these cases it is impossible for a compiler to directly translate source 
  		  code into machine code
  		  - these cases increase the importance of the runtime system
  		- Icon is a language with much of these features
  			- this means that the implementation of Icon leans much more heavily on 
  			  the runtime system than the compiler

Icon Language Overview
	- Note: The implementer of a programming language needs a very different 
	  understanding of the langugage of the one using it
	- stuff I dont already know
		- type checking is performed furing execution and automatic type conversion is 
		  provided
		- several operations are polymorphic, doing different operations depending on 
		  the types of the arguments
		- strings and structures are created during execution rather than being 
		  declared and allocated during compilation
		- structures have pointer semantics, each element in a structure is
		  represented as a pointer to an object
		- storage management is automatic
		- memory allocation is handled by garbage collection behind the scenes
		- the only limits on the size of objects is the practical capabilites of the 
		  computer architecture 
		- Icon programs are consisted of records, procedures and global identifiers
		- Icon has no block structure
		- scoping is static, identifiers are either global or local to procedures
		- Icon is expression based and has reserved-word syntax
	- Data Types
		- int, float, strings, csets
		- no char data type
		- strings of characters are not arrays, they are their own data object
		- 4 structure types, that compromise an aggregate of values
			- list, record, table, set
		- null value
		- procedures are also data values
			- procedures can be assigned to variables, returned and passed to 
			  functions, etc
			- cannot create procedures during program execution
		- co-expressions are  also data types
			- they are the express ion level analog of coroutines
			- their importance comes from Icon's expression evaluation mechanism
		- during execution, type checking is performed
			- ex. i := x + 1
			- the value of x is checked to be sure that it is numeric, and if it isnt 
			  it attempts to convert it
			- if it cannot be converted then a runtime error will occur and the  
			  program will be terminated
		- Note: Icon uses the "numeric" type as either a real or integer number
	- Expression Evaluation
		- in most programming languages an expression always produces exactly 1 result
		- in Icon the evaluation of an expression may produce a single result, no 
		  result, or a sequence of results
		- an expression that does not produce a result is said to fail while an 
		  expression that produces a result succeeds
		- success and failure are used to manipulate the flow of the program
		- Icon has no Boolean type
		- Failure in Icon does not indicate an error instead it indicates that there 
		  was no result produced
		- if an expression enclosed in another expression fails, the internal 
		  expression produces no result and the outer expression cannot perform the computation and also fails
		- this inheritance of failure allows computations to be written concisely
		- some expressions produce variables while some produce values
		- co-expressions
			- due to the nature of unicon and co-expressions, there are many 
			  complexities in the implementation
			- if there were no co-expressions, then generators would produce results 
			  that are limited to a single space in the program, and also it's scope can be determined during program translation
	- one of icons notable characteristics is it's freedom from the 
	  translation-time constraints and the ability to specify and change meanings at runtime

Language Features and implementations
	- values and variables
		- the absence of type delcarations has far reaching
		  implications
		- since any variable can be any type and the types of
		  variables can change during execution, we must have a wasy to represent values uniformly
		  - this is esepcially significant since Icon/Unicon has a 
		    wide variety of variable types that can be represented
		- The solution is heterogeneous structures
		- in some way no type delcarations makes implementation 
		  easier meaning that some of the work that is conventionally done by compilers can be ignored
		- however the problem is not avoidable, it just goes to
		  another part of the implementation
		- automatic tpye conversion goes hand in hand with lack of
		  type declarations
	- storage management
		- since structures and strings are created during
		  execution, the space must be allocated at runtime
		- this implies a need for some garbage collection
		  mechanism that will reclaim allocated memory after that memeory is no longer needed
		- the problem is further complicated by the diversity of
		  types and sizes of objects, the lack of size limitations and possible circular pointer loops in structures
	- strings
		- the emphasis of Icon is string processing 
		- there is the need for a well designed and coherent 
		  mechanism for handling strings
	- structures
		- Icons unusual structures that have sophisticated access
		  mechanisms also pose problems
		- specifically structures that can grow without limit
		  require different iplementation approaches than static structures
		- the ability of lists to support stack, and queue 
		  mechanisms will compromise efficient access for other uses
		- sets with values that can have any type, that also
		  provide a collection of set operations pose problems
		- tables are similar to sets but they also need more
		  attention since they add elements in a special way
	- procedures and functions
		- procedures and functions are values and must be
		  represented as data objects
		- this means that the meaning of a function call cannot be 
		  determined during translation
		- ex. write(s) may write string s or it might not 
		  depending on whether or not write still has it's initial value 
		- therefore procedures must be determined at runtime
	- polymorphic operations
		- operations cannot be changes during execution, but most
		  arguments support polymorphic arguments (of many different types)
		- also different operators ay have different meanings for 
		  assignment or dereferenceing
			- ex. s[i] := "hi"
				  is a different operation than
				  write(s[i])
				  but it uses the smae operator
		- overall the context is impossible to determine at 
		  translation time
	- expression evaluation
		- generators and co-expressions present obvious
		  implementation problems
		- there is little knowledge in the area of expression
		  evaluation in which expressions can produce a series of results in sequence
		- moreover, generators and co-expression can be applied to
		  every context with every data type
		- therefore the implementatipon requires a new approach
		- efficiency is a concern in this area more than others
		- the mechanism that handles expression evaluation also
		  has to be able to handle conventional single-result expressions as well
	- co-expressions	
		- only relavant because of goal-directed execution /
		  expression evaluation of unicon
		- without co-expressions, generators are limited to the 
		  place where they execute in the program
		- with co-expressions, generators can be activated at any
		  point in a program past their declaration

Organization of the Implementation
	- many factors influence the implementation of a language
		- properties of the language, goals, reseources, etc
	- Icon was developed with ease of modification in mind
	- Icon was developed for machines that only had 128K bytes of 
	  address space
	- The Icon Virtual Machine
		- the icon implementation is organized around a VM
		- VMs serve as software design tools for implementations
		  in which the operations of a language do not fit a particular computer architecture
		- also VMs do well if protability is a concern
		- most VM models do some translation that will map the VM 
		  operations onto the real machine 
		- during the design and development of an implementation 
		  a VM can an idealized model in which the ideosyncrasies of any real machine can be ignored
		- Icon's Virtual Machine is incomplete, it only includes
		  the expression evaluation mechanism and the computations on Icon data 
        - many aspects of the Icon runtime system are not
          represented in the VM
        	- type checking, storage allocation, garbage   
        	  collection
        - Icon's VM serves more as a guide/tool for organizing the
          implementation rather than a rigid structure
    - Components of the Implementation
    	- 3 major components: translator, linker, runtime system
    	- these all fall under the virtual machine implementation
    	- logicaly the translator and linker are different but 
    	  they are compiled as 1 program
    	- Translator Overview
    		- plays the role of compiler for the Icon VM
    		- converts source code into virtual machine
    		  instructions
    		- translator output is called ucode
    		- ucode is represented in ASCII which is useful for 
    		  debugging
    	- Linker Overview
    		- combines one or more ucode files into a single file 
    		  for the VM
    			- this allows programs to be written in multiple 
    		  	  modules
    		  	- also useful for giving users access to 
    		  	  pre-translated Icon libraries
    		- output of linker is called icode
    		- icode is represented in binary format
    		- ucode and icode are essentially the same just in a
    		  different format
    	- the process looks like this

    Icon program --> [ translator ] --> ucode [ linker ] --> icode

    	- these phases can be done seperately, if only phase 1
    	  happens you get ucode, which can be linked later
    	- the runtime system consists of an interpreter for icode
    	  and a library of support routines to carry out the various operations that may occur when an Icon program is executed
    	- the interpreter is the software realization of the Icon 
    	  VM
    - The Translator
    	- written in C
    	- independent of the architecture of the target machine
    	- ucode is portable
    	- consists of : lexical analyzer, parser, code generator, 
    	  a few support routines
    	- lexical analyzer converts a source program into a
    	  stream of tokens provided to the parser as needed
    	- the parser generates abtract syntax trees on a per
    	  procedure basis
    	- the syntax trees are then passed to the code generator 
    	  and converted to ucode
    	- the parser is generated automatically by Yacc from a 
    	  grammatical specification
    	- in the body of an icon procedure, a series of
    	  expressions are seperated by semicolons.
    	- these semicolons need not be provided explicitly
    	- the lexical analyzer can do automatic semicolon 
    	  insertion if a line ends with a token that legally ends
    	  an expression and the beginning of the next line starts with a token that can legally start an expression 
    	- if an expression spans 2 lines then the place to put 
    	  the semicolon is the first legal token to appear
    - The Linker
    	- the linker reads ucode files and writes icode files
    	- icode files starts with an executable header that loads
    	  the runtime system
    	- the rest of an icode file consists of file information,
    	  operations codes and operands, and data specific to that program
    	- the linker is written in C
    	- conversion from ucode to icode is mainly reformatting
    	- the linker does 2 other things besides icode conversion
		- scope resolution
			- if an identifier in a procedure is undeclared,
			  it's scope is dependent on global (explicit/implicit) delcarations in the program
			- the translator only can operate on 1 module of a
			  program at a time, so it cannot resolve the scope of undeclared identifiers
			- this is because not all global scope information is
			  contained in 1 module
			- the linker handles all the modules so it can
			  resolve the scope of these identifiers
			- an identifier may be global for several reasons
				- explicit global declaration
				- name in a record declaration
				- name in a procedure declaration
				- name of a built in function
			- if an identifier with no local delcaration falls
			  into 1 of these catagories, it is global, otherwise it is local
		- construction of runtime structures
			- a number of aspects of an icon program are
			  represented at runtime by various data structures
				- procedure blocks, strings, blocks for csets, and
				  real literals 
				- the ucode that represents this information is
				  machine-independent
				- the linker converts the information into the
				  appropriate format for the machine architecture
	- The Runtime System
		- the runtime system is mostly written in C, with a 
		  little assembly
		- there are 2 main reasons to concetrate most of the
		  implementation in the runtime system 
			- some icon features do not translate well directly
			  into executable code, since there is not a direct 
			  image for them in the target-machine's architecture. Therefore the target machine code necessary to carry out these operations would be too big to put in-line. Instead it is placed in the library routines called from the in-line code
				- examples include structure operations and 
				  string scanning
			- operations that cannot be determined at translation
			  time must be determined at runtime. 
				- examples of this include type checking to
				  string scanning to structure operations
		- there are 4 main logical parts of the runtime system
			- initialization and termination routines
				- init routine sets up regions in which objects 
				  created at runtime are allocated
				- init routine also initalizes some structures
				  that are used during program execution
				- after these tasks are done, control is 
				  transferred to the interpreter
				- when a program terminates in any way,
				  termination routines will flush all the output buffers and return control to the OS
			- the interpreter
				- the interpreter analyzes icode instructions and
				  their operands and performs the corresponding operations
				- the interpreter is not very complex, most
				  complex operations are performed by the library routines
			- the library routines
				- they are divided into 3 main catagories, Icon 
				  operator routines, Icon built in function routines, routines for complicated Icon VM operations
				- the meanings of operators are known to the 
				  translator/linker so they can be called directly
				- functions however cannot be determined until
				  they are executed, so functions are called indirectly
			- the support routines
				- include storage allocation and garbage
				  collection, type checking, conversion
				- normally, support routines are called by the 
				  library routines

Values and Variables
	- the features that has the greatest impact on the icon
	  implementation is untyped variables
	- the downside to untyped variables is that it makes it
	  impossible for the translator to catch type errors until runtime
	- also a person who is writing or reading an Icon program
	  does not have type declarations to help them clarify the programs intent
	- type checking and coversion are intertwined in the
	  implementation
	- untyped variables simplify the translator and complicate
	  the runtime system
	- since any variable can have any type of value at any time,
	  all values must have the same size
		- the problem to this solution is the descriptor, which
		  either contains the data, if it is small enough, or a pointer to the data
	- Descriptors
		- Every Icon value is represented by a descriptor
		- Icon descriptors must be small as possible, while also
		  containing enough information to determine the type of the value and locate the actual data
		- descriptors are composed of "words"
		- one word is not large enough to contain both the type 
		  information and the integer/pointer
		- so descriptors are made of 2 words, called the d-word, 
		  and the v-word
			- the d-word contains descriptive info
			- the v-word contains the value
		- different computer arhcitectures may have different
		  sizes for words and integers/pointers may not necessarily be the same size
			- Icon is mainly concerned with 32/64 bit 
			  architectures
			- also the large memory model in which pointers are
			  larger than integers, in this case the v-word must accommodate the largest of the types
		- d-words contain a type code, which is an integer, in 
		  their least significant bits, and flags in their most significant bits
		- there are 12 different type codes
			- data type | type code
			  null	      null
			  int 		    int or long
			  real num    real
			  cset    	  cset
			  file  	    file
			  procedure   proc
			  list 		    list
			  set 		    set
			  table 	    table
			  record	    record
			  co-expr  	  coexpr

			- there are other type codes for internal objects but 
			  they are not visible at the source-language level 
	- Strings
		- there is not type code for strings
		- they have a special representation where the d-word
		  contains the length of the string and the v-word points to the first character 
		- string descriptors are called qualifiers
		- in order to distinguish qualifiers from other
		  descriptors with type codes that are the same as the string length, all descriptors that are not qualifiers have an n flag in the MSB of the d-word
		- the d-words of qualifiers do not have the n flag and 
		  string lengths are prevented from overflowing into that flag's posiiton
	- Integers
		- Icon supports integers up to 32 bits in size 
		- as long as it fits, the value of an icon integer is 
		  stored in the v-word
		- integers are represented by 2 different type codes
			- integer for integers that are contained in v-words
			- lrgint for integers that are contained in blocks 
			  pointed to by the v-words of their descriptors
	- Blocks
		- blocks are what icon data is stored in when the v-word 
		  cannot hold the value
		- the first word of every block is called the title and
		  it contains a type code that is the same code in the d-word in the descriptor 
		- some blocks are fixed in size for all values of a given 
		  type
		- the p flag in the descriptor indicates that the v-word 
		  contains a pointer to a block
		- some other blocks have varying sizes for other types, 
		  like records
		- a block will never grow or shrink in size
		- if the type code in the title does not determine the
		  size of the block, the second word in the block contains it's size in bytes
		- many blocks contain an id field that is used to
		  distinguish between different blocks of the same type
		  	- the runtime system maintains seperate id counters
		  	  for blocks of different types
		- blocks may contain descriptors as well as 
		  non-descriptors like qualifiers
		  	- an example is record blocks which may contain
		  	  different data types for each field
		- non-descriptor data comes first in a block before the
		  descriptor data
		- the first descriptor in a block is constant for all
		  blocks of a given type, which helps with garbage collection
	- Variables
		- variables are also represented with descriptors just 
		  like values
		- variables to identifiers point to descriptors for the 
		  corresonding values
		- variable descriptors never point to other variable 
		  descriptors, always to value descriptors 
		- the v flag indicates that the descriptor is for a 
		  variable
		- the values of local identifiers are kept on a program
		  stack while static/global identifiers are kept in fixed locations in memory
		- a variable that references some value in a data 
		  structure references the start of the data structure and the least significant bits of the d-word will contain an offset (in words, not bytes) to the value you want to reference
		- Operations on variables
			- variables can be used in 2 fundamental contexts
			  dereferencing and assignment
			- for example the instruction write(s) for some
			  string s calls for the variable descriptor s to fetch the value descriptor holding "hello" that it is pointing to. This is dereferencing
			- say you also want to assign s := 13570. The value 
			  descriptor pointed to by the v word of the variable descriptor changes
		- Special Variables
			- Icon has special variables that make dereferencing and assignment more complex
			- an example is keywords
				- &trace is always an integer value
				- Consider &trace =: expr
				- the result of expr must be type checked/converted to make sure it is an 
				  integer
				- if we want to perform this checking on each assingment to a keyword, it 
				  would require a lot of computation
				- instead Icon divides variables into 2 classes, ordinary and trapped
			- Ordinary variables point to a value and need no special processing
			- Trapping variables are distingiushed by a t flag to indicate that it needs 
			  special processing
			- Trapped Variables
				- recent versions of unicon do not use trapped variables
				- instead special keyword variables have different descriptor types than 
				  normal variables
				- however they are still used for assignment to substrings, and table elements
				- ex. procedure tabvar(n)
							...
							return tb[n]
							end

							tabvar(5) := 10 # is equal to tb[5] := 10
				- for this example it is impossible for the translator to determine that 
				  tabvar(5) returns a variable tb[5] 
				- In this case, trapped variables are used to handle weird shit like this
			- Keyword Variables
				- keywords have thier own types since they always require special treatment
				- most special cases need only special processing for assignment and not
  			  dereferencing
  - Descriptors and Blocks in C
 		- Often in order to understand the implementation of previously explained concepts
 		  in Icon, it is useful to look at the C code
 		- Descriptors in C
 			- when ints and pointers are the same size, the word size is the size of an int
			  and if a pointer is larger than an int the word size is long or long long
			- this difference in memory models is handled by typedefs under the control of 	
			  conditional compilation
			- so depending on the memory model the architecture follows, one of two
			  typedefs will compile, which will determine the word size, and define the "word" type
			- Descriptors are declared as structs 

				struct descrip{
					word dword; // type field

					union {
						word integr; 
						#ifdef DescriptorDouble
							double realval
						#endif
						char *sptr; // string ptr
						union block *bptr; // block pointer, type defined elsewhere
						struct descrip *dptr; // ptr to a different descriptor
					} vword // value field
				};

			- the union represents that the vword can be various different values, int, str 
			  pointer, block pointer, descriptor pointer
		- Blocks in C
			- each block type has a different struct declaration
			- ex record block struct

					struct b_record {
						word title;
						word blksize;
						word id;
						union block *recdesc; // ptr to record constructor
						struct descrip fields[1];
					}

			- record blocks vary in size so for now we declare the fields array to be 1 
			  descrip struct in size;
			- actual blocks for records are constructed at run time in some region managed 
			  by Icon's storage allocator
			- Icon blocks conform to the C blocks except for the number of fields
			- The C declaration provides a means of accessing portions of blocks from C
			- ex. substring trapped variable blocks

					struct b_tvsubs {
						word title;						// T_Tvsubs
						word sslen;						// length of substring
						word sspos;						// position of substring
						struct descrip ssvar; // variable that substring is from
					}
			- the title fields contain type codes defined as C macros
			- the block union given in the record declaration has all the block types

				union block {
					struct b_real realblk;
					struct b_cset cset;
					struct b_file file;
					struct b_proc proc;
					struct b_list list;
					struct b_lelem lelem;
					struct b_table table;
					struct b_telem telem;
					struct b_set set;
					struct b_selem selem;
					struct b_record record;
					struct b_tvsubs tvsubs;
					struct b_tvtbl tvtbl;
					struct b_refresh refresh;
					struct b_coexpr coexpr;
					struct b_externl externl;
					struct b_slots slots;
					struct b_bignum bignumblk;
				}

			- Note : there are other block types besides the source language data types
		- Defined Constants
			- type codes are defined symbolically as macros

				#define T_Null 0
				#define T_Integer 1
				#define T_Lrgint 2
				#define T_Real 3
				#define T_Cset 4
				#define T_File 5
				#define T_Proc 6
				#define T_Record 7
				#define T_List 8
				#define T_Lelem 9
				#define T_Set 10
				#define T_Selem 11
				#define T_Table 12
				#define T Telem 13
				#define T_Tvtbl 14
				#define T_Slots 15
				#define T_Tvsubs 16
				#define T_Refresh 17
				#define T_Coexpr 18
				#define T_External 19

			- d word flags also have defined constants

					n F_Nqual
					p F_Ptr
					v F_Var
					t F_Tvar

			- the d words themselves are defined as constants by bitwise expressions

				#define D_Null (T_Null | F_Nqual)
				#define D_Integer (T_Integer | F_Nqual)
				#define D_Lrgint (T_Lrgint | F_Ptr | F_Nqual)
				#define D_Real (T_Real | F_Ptr | F_Nqual)
				#define D_Cset (T_Cset | F_Ptr | F_Nqual)
				#define D_File (T_File | F_Ptr | F_Nqual)
				#define D_Proc (T_Proc | F_Ptr | F_Nqual)
				#define D_List (T_List | F_Ptr | F_Nqual)
				#define D_Table (T_Table | F_Ptr | F_Nqual)
				#define D_Set (T_Set | F_Ptr | F_Nqual)
				#define D_Selem (T_Selem | F_Ptr | F_Nqual)
				#define D_Record (T_Record | F_Ptr | F_Nqual)
				#define D_Telem (T_Telem | F_Ptr | F_Nqual)
				#define D_Lelem (T_Lelem | F_Ptr | F_Nqual)
				#define D_Tvsubs (T_Tvsubs | D_Tvar)
				#define D_Tvtbl (T Tvtbl | D_Tvar)
				#define D_Coexpr (T_Coexpr | F_Ptr | F_Nqual)
				#define D_Refresh (T_Refresh | F_Ptr | F_Nqual)
				#define D_Var (F_Var | F_Nqual | F_Ptr)
				#define D_Tvar (D_Var | F_Tvar)

		- RTL Coding
			- the optimizing compiler was introduced later in Icon (version 8/9) so the 
			  routines for the runtime system use an extended C syntax called the RTL (Run-Time Language)
			- operator{} is a construct that doe smultiple things
				- the first is to declare a C function that the interpreter will call
				- operator{1} * size(x) declares a C function size() for the * operator
				- the arguments and results are descriptors
			- RTL extends C's return statement to include type information, which allows
			  the d-word of the return value to be changed the appropriate type
			- RTL's type_case is like a switch statement which executes different code 
			  based off the type of the input

Strings and Csets
	- in Icon, strings are the most commin data type used
	- therefore storage and access of string data is necessary
	- also the efficiency of frequently used operation is important like *
	- string lengths are determined dynamically during execution
	- the automatic storage management of strings in Icon is what gives much of the
	  advantage to Icon for string processing 
	- any of the 256 8-bit ASCII characters can be represented even the NULL character
	- several Icon string operations retun substrings of a string 
	- Icon strings are atomic, meaning that three are no string operations in Icon that
	  change the characters in existing strings
	- this is not obvious, there are operations that appear to change the characters in 
    strings, but they don't
  - the atomic nature of strings simplifies the implementation 
  	- an example would be the assignment of a string value to a variable 
  	- the string value is not copied in this case since the string will not change
 	- the order of the characters in a string is very important, csets are provided 
 	  when several characters have the same status and the order is not relevant

 	- Representation of Strings
 		- C represents strings as arrays of characters as successive bytes in memory
 		  terminating in a null byte
 			- a disadvantage of this is that you need to index through the string to find 
 			  it's size
 			- since every string in C terminates with a null byte, substrings cannot exist 
 			  within strings
 		- Icon does not use null characters, therefore there must be some external way to
 		  determine the end of the string 
 		- this is the motivation for the qualifier representation
 			- the qualifier includes the address of the first character and it's length
 		- this representation (with no null char) allows for quick computation of 
 		  substrings
 		- Note : C style strings can be utilized by Icon since qualifiers can easily 
 		  handle C strings, but C cannot utilize Icon strings without copying and appending a \0
 		- Some strings are compiled at runtime, while others like string literals can be 
 		  contained in the icode
 		- during execution, strings may be stored in work areas (usually buffers)
 		- when new strings are created during execution, they are allocated in a common 
 		  string region
 			- when source-code operations create a new string, its characters are appended 
 			  to the end of the strings already in the common string region
 			- the string region will continue to fill up until it is full and it has to be 
 			  compacted by the garbage collector, which sweeps away unneeded chars

 		- Concatenation
 			- ex. 
 					s1 := "ab" || "cdef"
 				- in this example the concatenation operation allocates a space for 6 chars 
 				  and it copies the 2 strings into that space, which is assigned a qualifier s1
 			- there are important optimization cases for concatenation
 				- if the first argument is the last string in the string region, then the
 				  second argument is appended to the end of the string region
 					- so 
 							s := s || str 

 							will perform less allocation than

 							s := str || s

 				- if the strings being concatenated are already adjacent in the string region 
 				  then you dont have to do anything
 				- other than that string construction operations will never use another
 				  instance of a string that may exist elsewhere in the string region  
 			- RTL code for concatenation

 				operator{1} || cater(x,y)
 				if !cnv:string(x) then
 					runerr(103, x)
 				if !cnv:string(y) then 
 					runerr(103, y)

 				abstract {
 					return string
 				}
 				body {
 					CURTSTATE();

 					/*
 					 * Optimization 1: Strings are adjacent in string region, no allocation
 					 */
 					if(StrLoc(x) + StrLen(x) == StrLoc(y)) {
 						StrLoc(result) = StrLoc(x);
 						StrLoc(result) = StrLen(x) + StrLen(y)
 						return result
 					}

 					else if ((StrLoc(x) + StrLen(x) == strfree)
 					&& (DiffPtrs(strend, strfree) > StrLen(y)) {

 					/*
					 * Optimization 2: The end of x is at the end of the string space.
					 * Hence, x was the last string allocated and need
					 * not be re-allocated. y is appended to the string
					 * space and the result is pointed to the start of x.
					 */
					result = x;

					/*
					 * Append y to the end of the string space.
					 */
					Protect(alcstr(StrLoc(y),StrLen(y)), runerr(0));

					/*
					 * Set the length of the result and return.
					 */

					StrLen(result) = StrLen(x) + StrLen(y);
					return result;
						}

					/*
					* Otherwise, allocate space for x and y, and copy them
					* to the end of the string space.
					*/
					Protect(StrLoc(result) = alcstr(NULL, StrLen(x) + StrLen(y)), runerr(0));
					memcpy(StrLoc(result), StrLoc(x), StrLen(x));
					memcpy(StrLoc(result) + StrLen(x), StrLoc(y), StrLen(y));

					/*
					 * Set the length of the result and return.
					 */
					StrLen(result) = StrLen(x) + StrLen(y);
					return result;
					}
				end

		- Substrings
			- ex. 
					s2 := s1[3:6] # s1 --> "abcdef"
				- this operation does not actually allocate a new string
				- the operation actually porduces a new qualifier which points to the 
				  beginning of the substring and includes the size of the substring
				- in this example the substring would point to c and have a contain a size of 
				 3
			- this allows substrings to be retrieved while maintaining the characters in  
			  original string 
			- Again the difference between C strings and Icon strings is that Icon strings 
        are atomic, immuatable, indivisible objects, while C strings are arrays of chars
      - there are operations that appear to change the chars of a string 
      	- ex.
      			s1[3] := "x"

      			is the same as 

      			s1 := s1[1:3] || "x" || s1[4:0]
      		- a new string is created from the concatenation
 					- this type of operation opens up the possibility to change the length of a 
 					  string by assignment to a substring,
 					  - ex.
 					  		s1[3] := "xxx" ---> s1[3] := s1[1:3] || "xxx" || s1[4:0]
 					  		s1[2:5] := "" --->  s1[1:2] || "" || s[5:0]

 		- Assignment to Subscripted Strings
 			- first off x[i] and x[i:j] are more complicated in Icon than they may appear
 			- the translator cannot determine the type of x in the first place
 				- x may be a string, list, table, or record
 				- also the operation performed is different for different types
 			- the translator also cant determine if a subscript expression is performing 
 			  assignment or dereferencing
 			  - ex. 
 			  		write(s[2:5])    # dereference
 			  		s[2:5] := "xxx"  # assignment
 			- the solution is trapped variables, also used for keywords
 				- a substring trapped variable has a t flag and the typecode tvsubs, with a 
  			  pointer to a block that contains another typecode tvsubs, the length, the offset and another pointer to a qualifier that represents the string
  			- Note : the trapped variable substring block and the 
  			  variable descriptor both point to the same qualifier, which makes it possible for assingment to a substring to change the actual string held by the variable 
  			- the length and offset of the substring varible block is 
  			  what allows for the production of a qualifier for the substring
  			- so since the variable block and the original variable 
  			  qualifier point to the same string, if the value of the substring is changed by through assignment 
  			  (concatenation), the string value stored in the original variable qualifier will also change
  				- ex. 
  					s := "123456"
  					s[2:4] := "x"
  					write(s) # --> prints "1x456"
  			- after substring assignment the length of the subscripted
  			  portion of the string will change to reflect the length of the string that was assigned to it

  		- String Mapping
  			- Recall map() usage :
  				ex. write(map("01234", "43210", "abcde")
					-> returns "edcbe" 

  			- The mapping is done using the character array maptab.
  			- the array is created by first assigning every possible
  			  character to its own position in maptab (0 -> 255)
  			  	- maptab[i] = i
  			- then for each character in s2, the position in 
  			  maptab corresponding to the value of that character in s2 is assigned the value of the character in s3 that has the same position
  			  	- Note : s2 and s3 are &ucase, &lcase by default
  			  	- maptab[s2[j]] = s3[j] 
  			  	  # where j - range(0, len(s2)) 
  			- to avoid rebuilding maptab this step can be skipped if the
  			  previous map call used the same s2 and s3. the global variables maps2 and maps3 hold the cached values
  			- Now that the maptab is built, you can run through s1 and 
  			  map out the new string using the maptab array
  				- while(slen-- > 0)
  				      *str2++ = maptab[*str1++]
  	- Csets
  		- there are a possible 256 different characters that can occur 
  		  in csets
  		- cset blocks consist of the title, number of characters
  		- next in the block comes a bunch of words, containing a total 
  		  of 256 bits, with each bit in each word representing 1 character
  		  - for a wordszie of 32 bits, then the words are 8 bits and 
  		    there will be 32 words in the cset block other than the title and length
  		- if the bit is set, then it is present in the cset, if not, it 
  		  is not present in the cset 
  		- cset block C structure
  			
  			struct b_cset {
  				word title;
  				word size;
  				unsigned int bits [CsetSize]
  			}

  		- CsetSize is the number of words it takes to add to 256 bits
  		- not very many programs use the size of the cset so the size
  		  field is initially set to -1 and the actual size is computed if its needed
		- cset operations are fairly straighforward
		- the characters in a cset are represented by a bit vector of 
		  bits divided into words

Lists
	- most programming languages provide an array or vector data type to 
	  access data elements by position
	- icon lists are different becuase they are constructed during
	  runtime rather than during compile time
	- this means that the size of the list is not known until runtime
	- a list value is actually a descriptor that points to a block
	  structure that holds the elements
	- so lists are passed by reference in this way
	- the biggest implementation issue of lists is their ability to grow
	  and shrink through the stack and queue operations		

	- Structure of Lists
		- a list consists of a fixed size list-header block
		- a list-header block contains...
			- title
			- current size of the list
			- block pointers that point to the first and last blocks of 
			  a doubly-linked chain of list-element blocks that contain the actual list elements
		- list element blocks vary in size
		- C struct for list header block

				struct b_list { /* list-header block */
					word title; /* T_List */
					word size; /* current list size */
					word id; /* identification number */
					union block *listhead; /* first list-element block */
					union block *listtail; /* last list-element block */
				};

		- a list-element block contains...
			- title
			- size of block in bytes
			- 3 words used to determine the location of the elements in the the block
			- block pointers that point to the next and previous list-element blocks
			- slots for elements
		- C struct for list-element block

				struct b_lelem { /* list-element block */
					word title; /* T_Lelem */
					word blksize; /* size of block */
					word nslots; /* total number of slots */
					word first; /* index of first used slot */
					word nused; /* number of used slots */
					union block *listprev; /* previous list-element block */
					union block *listnext; /* next list-element block */
					struct descrip lslots[1]; /* array of slots */
				};
		- when a list is initialized in the source code there is only one list element 
		  block, others are added to the chain with pushes or puts
		- list element blocks have a minimum number of slots which allows for extra room 
		  when adding new elements to lists that grow over time list adding an empty list that will grow later
		- Normally the minimum number of slots is 8
		- put() adds an element to the end of the list
		- push() adds an element to the front of the list
		- Note: since the slots are a circular doubly linked list, what keeps track of
		  the front of the list is the information contained in the header of the list-element block that keep track of the number of total slots, the first slot used, and the number of slots used. it may appear as though the list elements do not appear in the correct order but they are correct
		- when you remove an element, it does not shorten the list-element block or
		  overwrite anything, it just becomes inaccessable
		- In the case of a list-element block slots becoming full, then a new block is 
		  allocated and linked in
		- the size of the new block is either half the number of elements in the entire
		  list, or MinListSlots
		- Unicon imposes an upper limit MaxListSlots
		- looking at diagrams in book makes it much more clear
		- If a block has all of it's elements removed, it will still be linked to the 
		  other blocks (first slot used will be 0)
			- this is to ensure that there is always at least 1 list-element block even if 
			  the list is empty
			- the only time when a list-element block is removed is when an element is
			  removed from a list in which the chain contains an empty list-element block, then you can remove the empty block

	- Positional Access
		- to get a[i] it requires locating the correct list-element block
		- if a list has several LE blocks then you have to link through the blocks while
		  keeping track of how many elements you've seen until you find the i'th element
		- a[i] will return a variable descriptor that points to the right slot in the LE 
		  block

	- Array Access (Unicon only)
		- Unicon offers an optimzed special list structure for fast access to list 
		  elements
		- a unicon array is a list where all the elements are the same type and are in a 
		  single block, all contained in consecutive slots
		- since all the elements are the same type, they can be accessed very fast by 
		  indexing
		- if any operation is performed on an array that would only be able to be
		  performed on a list it is converted to one
			- an example would be push(), put(), replacing an element for one of a 
			  different type, etc

Sets and Tables	
	- sets and tables are data aggregates that few languages support
	- the main reason that these data types do not exist in many lnaguages is because 
	  of the difficulty of implementation
	- sets support the common mathematical operations that you find over finite sets
		- union, intersection, difference, removal, insertion, membership
	- sets in Icon can contain members of any type
	- there are many attributes of sets that cause the implementation to become more
	  difficult
		- heterogeneity of members
		- ability to grow/shrink
		- efficient access
		- insertion and deletion of members
		- arbitrarily large sets
	- tables on the other hand have more structure
	- a table is a set of pairs that represents a many-to-one relationship function
	- programmers use them more literally, using them to tabulate a set of values

	- Sets
		- Data Organization for sets
			- hash lookup and linked lists are used to provide an efficient way of 
			  locating set members
			- for every set, there is a set header block that contains...
				- a word for the number of elements in the set
				- slots that serve as heads of linked lists of set-element blocks
			- So the way that data is stored in sets is with a hash table
				- the hash table is split up into segments with the first segement having
				  the least number of slots and the following segments each being twice as large as the last
				- the reason for this is because small tables benefit from reduced memory 
					and large tables have better performance
				- each set element is stored in a set-element block
					- set element blocks are the nodes in the linked lists and they contain...
						- a desriptor for it's value, the hash number and a pointer to the next 
						  node
				- whenever an element is looked up, a hash number is computed from it's value
					- the hash function is --> 8 * golden ratio * value
				- the absolute value of the remainder resulting from dividing this hash
				  number by the number of slots is it's spot in the hash table
				- the hash number of the value being looked up is compared with the hash 
				  numbers on the set-element blocks
				- If there is a match, the values may or may not be the same, since 
				  collisions are unavoidable. but it is necassary now to compare the values to determine if they are the same
				- the set-element block nodes are ordered by their hash numbers, so that
				  when the linked list is being examined, the search stops if the hash number of an element on the list is greater than the hash number of the
				  value being looked up
				- when the lookup is for the purpose of insertion, then if the value is not 
					found, then a new set-element block is allocated and inserted into the list
		- Set Operations
			- union, intersection, and difference all produce new sets and do not modify 
			  their arguments
			- union
				- a copy of the larger set is made first, includes set-header and all 
				  set-element blocks, no lookups required
				- then each element in the smaller set is inserted by lookup
				- the insertions may take longer however since the linked lists may be longer
			- intersection
				- a copy of the smaller set is made and any member that is not in the larger 
				  set is omitted
			- difference
				- a copy of the first argument set is made, adding only elements that are 
				  not in the second argument set
				- involves looking up all arguments of the first set in the second

	Tables
		- similar to sets with an added default value descriptor in the table-header 
		  block
		- table lookup is more complicated then set lookup since table elements can 
		  contain both an entry value and an assigned value (key, value pair)
		- also table entries can be referenced by either value
		- a table element block contains...
			- pointer to next table element block node in the list
			- the hash number
			- the entry value descriptor
			- the assigned value descriptor
		- table reference t[x] uses x as the hash parameter to compute a hash value and 
		  select a slot
		- the corresponding list is then searched for the block that contains the same 
		  entry value
		- in sets the values are compared only if the hashes are the same
		- if a matching entry value is found then a variable descriptor is created that
		  points to the corresponding assigned value
		  - this is done so that the assigned value can be used in assignment/
		    dereferencing
		- if a matching entry is not found, then either, the default value is returned 
		  (dereferencing), or a new element is added to the table (assignment)
		- this is done through trapped variables like with substrings


































































