Question
	
I understand how the every do construct works, but what about when it's just every, without a do? (every write(1 to 10)) Does this just mean that whenever a result is produced for the expression, there is an automatic failure after every suspend until the generator does not produce another result

Why is mutual evaluation useful? I messed around with it a little and it it seems you can use it kind of like a switch statement for assignment, if you set the operand before the parenthesis to an integer variable. I tried to make the arguments generators and it would only produce the first suspended result. Are there any more cool uses for it? Maybe handling multiple co-expression activations?

I know that by default structures are passed by reference as procedure parameters.
Would it be possible to pass a structure by value? Perhaps you have a small structure and you would prefer to access that structure directly in the procedure rather than having to do a memory lookup. 

Is it possible to pass a list to a procedure as it's arguments?
	ex. 
			instead of ... 
			foo(arg1, arg2, arg3, ..., argn)

			we could do ...
			a := [arg1, arg2, arg3, ..., argn]
			foo(a)

How does circular list access work in Unicon? I was trying to do it but since lists index at zero, a list with n elements has no n % n element, i.e. list[n % n] --> list[0] does not exist. A quick and dirty fix for it is to add a dummy element to the end of the list and just increase the modulo rhs operand by 1. 

In the book it says, the macro FncDel occurs at the beginning of every C function that implements an Icon function. I did a grep search but I couldn't find an instance of this macro.

Notes for Icon/Unicon implementation textbook

Preface
	- multiple compilers
		- icont/iconc
			- these are compilers that users use to translate unicon code into machine 
			  code
				- iconc breaks icon code down to C code
				- icont breaks icon code down to virtual machine code
			- a preprocessor called unicon translates unicon code into icon code which 
			  then compiles using iconc/
			- "unicon" is written in unicon
		- iconx
			- iconx is the name of the Unicon/Icon virtual machine
			- consists of a collection of high-level data-structure and I/O facilites,
			  which are built in to icon/unicon
		- rt.a
			- the runtime library that is linked to Icon programs compiled with iconc
			- shared much of the code with iconx
		  to machine instructions for the computer to execute
		- this translation process is called compilation
		- in addition to a compiler most language implemetations include a run-time
		  component that contains subroutines for performing computations that are too complex to compile in-line, such as I/O and mathematical fucntions
		- some languages have features whose meanings change during program execution.
			- this makes these features unable to be determined statically from the 
  			  text of a source-language program 
  			- examples of these features are
  				- changing of fucntion meanings during execution
  				- creation of new data types at run-time
  				- self-modifying programs
  		- also some languages have features that do not match up with the architecture
  		  of conventional computers such as pattern matching
  		- in these cases it is impossible for a compiler to directly translate source 
  		  code into machine code
  		  - these cases increase the importance of the runtime system
  		- Icon is a language with much of these features
  			- this means that the implementation of Icon leans much more heavily on 
  			  the runtime system than the compiler

Introduction
	- Implementing Programming Languages
		- in conventional programming languages most of the operations that are
		  performed upon execution can be determined statically by examining the code beforehand
		- also, most programming languages' operations closely correspond to the 
		  architecture of the computers on which they are executed
		- when these two conditions are met it is easy to map source code instructions 

Icon Language Overview
	- Note: The implementer of a programming language needs a very different 
	  understanding of the langugage of the one using it
	- stuff I dont already know
		- type checking is performed furing execution and automatic type conversion is 
		  provided
		- several operations are polymorphic, doing different operations depending on 
		  the types of the arguments
		- strings and structures are created during execution rather than being 
		  declared and allocated during compilation
		- structures have pointer semantics, each element in a structure is
		  represented as a pointer to an object
		- storage management is automatic
		- memory allocation is handled by garbage collection behind the scenes
		- the only limits on the size of objects is the practical capabilites of the 
		  computer architecture 
		- Icon programs are consisted of records, procedures and global identifiers
		- Icon has no block structure
		- scoping is static, identifiers are either global or local to procedures
		- Icon is expression based and has reserved-word syntax
	- Data Types
		- int, float, strings, csets
		- no char data type
		- strings of characters are not arrays, they are their own data object
		- 4 structure types, that compromise an aggregate of values
			- list, record, table, set
		- null value
		- procedures are also data values
			- procedures can be assigned to variables, returned and passed to 
			  functions, etc
			- cannot create procedures during program execution
		- co-expressions are  also data types
			- they are the express ion level analog of coroutines
			- their importance comes from Icon's expression evaluation mechanism
		- during execution, type checking is performed
			- ex. i := x + 1
			- the value of x is checked to be sure that it is numeric, and if it isnt 
			  it attempts to convert it
			- if it cannot be converted then a runtime error will occur and the  
			  program will be terminated
		- Note: Icon uses the "numeric" type as either a real or integer number
	- Expression Evaluation
		- in most programming languages an expression always produces exactly 1 result
		- in Icon the evaluation of an expression may produce a single result, no 
		  result, or a sequence of results
		- an expression that does not produce a result is said to fail while an 
		  expression that produces a result succeeds
		- success and failure are used to manipulate the flow of the program
		- Icon has no Boolean type
		- Failure in Icon does not indicate an error instead it indicates that there 
		  was no result produced
		- if an expression enclosed in another expression fails, the internal 
		  expression produces no result and the outer expression cannot perform the computation and also fails
		- this inheritance of failure allows computations to be written concisely
		- some expressions produce variables while some produce values
		- co-expressions
			- due to the nature of unicon and co-expressions, there are many 
			  complexities in the implementation
			- if there were no co-expressions, then generators would produce results 
			  that are limited to a single space in the program, and also it's scope can be determined during program translation
	- one of icons notable characteristics is it's freedom from the 
	  translation-time constraints and the ability to specify and change meanings at runtime

Language Features and implementations
	- values and variables
		- the absence of type delcarations has far reaching
		  implications
		- since any variable can be any type and the types of
		  variables can change during execution, we must have a wasy to represent values uniformly
		  - this is esepcially significant since Icon/Unicon has a 
		    wide variety of variable types that can be represented
		- The solution is heterogeneous structures
		- in some way no type delcarations makes implementation 
		  easier meaning that some of the work that is conventionally done by compilers can be ignored
		- however the problem is not avoidable, it just goes to
		  another part of the implementation
		- automatic tpye conversion goes hand in hand with lack of
		  type declarations
	- storage management
		- since structures and strings are created during
		  execution, the space must be allocated at runtime
		- this implies a need for some garbage collection
		  mechanism that will reclaim allocated memory after that memeory is no longer needed
		- the problem is further complicated by the diversity of
		  types and sizes of objects, the lack of size limitations and possible circular pointer loops in structures
	- strings
		- the emphasis of Icon is string processing 
		- there is the need for a well designed and coherent 
		  mechanism for handling strings
	- structures
		- Icons unusual structures that have sophisticated access
		  mechanisms also pose problems
		- specifically structures that can grow without limit
		  require different iplementation approaches than static structures
		- the ability of lists to support stack, and queue 
		  mechanisms will compromise efficient access for other uses
		- sets with values that can have any type, that also
		  provide a collection of set operations pose problems
		- tables are similar to sets but they also need more
		  attention since they add elements in a special way
	- procedures and functions
		- procedures and functions are values and must be
		  represented as data objects
		- this means that the meaning of a function call cannot be 
		  determined during translation
		- ex. write(s) may write string s or it might not 
		  depending on whether or not write still has it's initial value 
		- therefore procedures must be determined at runtime
	- polymorphic operations
		- operations cannot be changes during execution, but most
		  arguments support polymorphic arguments (of many different types)
		- also different operators ay have different meanings for 
		  assignment or dereferenceing
			- ex. s[i] := "hi"
				  is a different operation than
				  write(s[i])
				  but it uses the smae operator
		- overall the context is impossible to determine at 
		  translation time
	- expression evaluation
		- generators and co-expressions present obvious
		  implementation problems
		- there is little knowledge in the area of expression
		  evaluation in which expressions can produce a series of results in sequence
		- moreover, generators and co-expression can be applied to
		  every context with every data type
		- therefore the implementatipon requires a new approach
		- efficiency is a concern in this area more than others
		- the mechanism that handles expression evaluation also
		  has to be able to handle conventional single-result expressions as well
	- co-expressions	
		- only relavant because of goal-directed execution /
		  expression evaluation of unicon
		- without co-expressions, generators are limited to the 
		  place where they execute in the program
		- with co-expressions, generators can be activated at any
		  point in a program past their declaration

Organization of the Implementation
	- many factors influence the implementation of a language
		- properties of the language, goals, reseources, etc
	- Icon was developed with ease of modification in mind
	- Icon was developed for machines that only had 128K bytes of 
	  address space
	- The Icon Virtual Machine
		- the icon implementation is organized around a VM
		- VMs serve as software design tools for implementations
		  in which the operations of a language do not fit a particular computer architecture
		- also VMs do well if protability is a concern
		- most VM models do some translation that will map the VM 
		  operations onto the real machine 
		- during the design and development of an implementation 
		  a VM can an idealized model in which the ideosyncrasies of any real machine can be ignored
		- Icon's Virtual Machine is incomplete, it only includes
		  the expression evaluation mechanism and the computations on Icon data 
        - many aspects of the Icon runtime system are not
          represented in the VM
        	- type checking, storage allocation, garbage   
        	  collection
        - Icon's VM serves more as a guide/tool for organizing the
          implementation rather than a rigid structure
    - Components of the Implementation
    	- 3 major components: translator, linker, runtime system
    	- these all fall under the virtual machine implementation
    	- logicaly the translator and linker are different but 
    	  they are compiled as 1 program
    	- Translator Overview
    		- plays the role of compiler for the Icon VM
    		- converts source code into virtual machine
    		  instructions
    		- translator output is called ucode
    		- ucode is represented in ASCII which is useful for 
    		  debugging
    	- Linker Overview
    		- combines one or more ucode files into a single file 
    		  for the VM
    			- this allows programs to be written in multiple 
    		  	  modules
    		  	- also useful for giving users access to 
    		  	  pre-translated Icon libraries
    		- output of linker is called icode
    		- icode is represented in binary format
    		- ucode and icode are essentially the same just in a
    		  different format
    	- the process looks like this

    Icon program --> [ translator ] --> ucode [ linker ] --> icode

    	- these phases can be done seperately, if only phase 1
    	  happens you get ucode, which can be linked later
    	- the runtime system consists of an interpreter for icode
    	  and a library of support routines to carry out the various operations that may occur when an Icon program is executed
    	- the interpreter is the software realization of the Icon 
    	  VM
    - The Translator
    	- written in C
    	- independent of the architecture of the target machine
    	- ucode is portable
    	- consists of : lexical analyzer, parser, code generator, 
    	  a few support routines
    	- lexical analyzer converts a source program into a
    	  stream of tokens provided to the parser as needed
    	- the parser generates abtract syntax trees on a per
    	  procedure basis
    	- the syntax trees are then passed to the code generator 
    	  and converted to ucode
    	- the parser is generated automatically by Yacc from a 
    	  grammatical specification
    	- in the body of an icon procedure, a series of
    	  expressions are seperated by semicolons.
    	- these semicolons need not be provided explicitly
    	- the lexical analyzer can do automatic semicolon 
    	  insertion if a line ends with a token that legally ends
    	  an expression and the beginning of the next line starts with a token that can legally start an expression 
    	- if an expression spans 2 lines then the place to put 
    	  the semicolon is the first legal token to appear
    - The Linker
    	- the linker reads ucode files and writes icode files
    	- icode files starts with an executable header that loads
    	  the runtime system
    	- the rest of an icode file consists of file information,
    	  operations codes and operands, and data specific to that program
    	- the linker is written in C
    	- conversion from ucode to icode is mainly reformatting
    	- the linker does 2 other things besides icode conversion
		- scope resolution
			- if an identifier in a procedure is undeclared,
			  it's scope is dependent on global (explicit/implicit) delcarations in the program
			- the translator only can operate on 1 module of a
			  program at a time, so it cannot resolve the scope of undeclared identifiers
			- this is because not all global scope information is
			  contained in 1 module
			- the linker handles all the modules so it can
			  resolve the scope of these identifiers
			- an identifier may be global for several reasons
				- explicit global declaration
				- name in a record declaration
				- name in a procedure declaration
				- name of a built in function
			- if an identifier with no local delcaration falls
			  into 1 of these catagories, it is global, otherwise it is local
		- construction of runtime structures
			- a number of aspects of an icon program are
			  represented at runtime by various data structures
				- procedure blocks, strings, blocks for csets, and
				  real literals 
				- the ucode that represents this information is
				  machine-independent
				- the linker converts the information into the
				  appropriate format for the machine architecture
	- The Runtime System
		- the runtime system is mostly written in C, with a 
		  little assembly
		- there are 2 main reasons to concetrate most of the
		  implementation in the runtime system 
			- some icon features do not translate well directly
			  into executable code, since there is not a direct 
			  image for them in the target-machine's architecture. Therefore the target machine code necessary to carry out these operations would be too big to put in-line. Instead it is placed in the library routines called from the in-line code
				- examples include structure operations and 
				  string scanning
			- operations that cannot be determined at translation
			  time must be determined at runtime. 
				- examples of this include type checking to
				  string scanning to structure operations
		- there are 4 main logical parts of the runtime system
			- initialization and termination routines
				- init routine sets up regions in which objects 
				  created at runtime are allocated
				- init routine also initalizes some structures
				  that are used during program execution
				- after these tasks are done, control is 
				  transferred to the interpreter
				- when a program terminates in any way,
				  termination routines will flush all the output buffers and return control to the OS
			- the interpreter
				- the interpreter analyzes icode instructions and
				  their operands and performs the corresponding operations
				- the interpreter is not very complex, most
				  complex operations are performed by the library routines
			- the library routines
				- they are divided into 3 main catagories, Icon 
				  operator routines, Icon built in function routines, routines for complicated Icon VM operations
				- the meanings of operators are known to the 
				  translator/linker so they can be called directly
				- functions however cannot be determined until
				  they are executed, so functions are called indirectly
			- the support routines
				- include storage allocation and garbage
				  collection, type checking, conversion
				- normally, support routines are called by the 
				  library routines

Values and Variables
	- the features that has the greatest impact on the icon
	  implementation is untyped variables
	- the downside to untyped variables is that it makes it
	  impossible for the translator to catch type errors until runtime
	- also a person who is writing or reading an Icon program
	  does not have type declarations to help them clarify the programs intent
	- type checking and coversion are intertwined in the
	  implementation
	- untyped variables simplify the translator and complicate
	  the runtime system
	- since any variable can have any type of value at any time,
	  all values must have the same size
		- the problem to this solution is the descriptor, which
		  either contains the data, if it is small enough, or a pointer to the data
	- Descriptors
		- Every Icon value is represented by a descriptor
		- Icon descriptors must be small as possible, while also
		  containing enough information to determine the type of the value and locate the actual data
		- descriptors are composed of "words"
		- one word is not large enough to contain both the type 
		  information and the integer/pointer
		- so descriptors are made of 2 words, called the d-word, 
		  and the v-word
			- the d-word contains descriptive info
			- the v-word contains the value
		- different computer arhcitectures may have different
		  sizes for words and integers/pointers may not necessarily be the same size
			- Icon is mainly concerned with 32/64 bit 
			  architectures
			- also the large memory model in which pointers are
			  larger than integers, in this case the v-word must accommodate the largest of the types
		- d-words contain a type code, which is an integer, in 
		  their least significant bits, and flags in their most significant bits
		- there are 12 different type codes
			- data type | type code
			  null	      null
			  int 		    int or long
			  real num    real
			  cset    	  cset
			  file  	    file
			  procedure   proc
			  list 		    list
			  set 		    set
			  table 	    table
			  record	    record
			  co-expr  	  coexpr

			- there are other type codes for internal objects but 
			  they are not visible at the source-language level 
	- Strings
		- there is not type code for strings
		- they have a special representation where the d-word
		  contains the length of the string and the v-word points to the first character 
		- string descriptors are called qualifiers
		- in order to distinguish qualifiers from other
		  descriptors with type codes that are the same as the string length, all descriptors that are not qualifiers have an n flag in the MSB of the d-word
		- the d-words of qualifiers do not have the n flag and 
		  string lengths are prevented from overflowing into that flag's posiiton
	- Integers
		- Icon supports integers up to 32 bits in size 
		- as long as it fits, the value of an icon integer is 
		  stored in the v-word
		- integers are represented by 2 different type codes
			- integer for integers that are contained in v-words
			- lrgint for integers that are contained in blocks 
			  pointed to by the v-words of their descriptors
	- Blocks
		- blocks are what icon data is stored in when the v-word 
		  cannot hold the value
		- the first word of every block is called the title and
		  it contains a type code that is the same code in the d-word in the descriptor 
		- some blocks are fixed in size for all values of a given 
		  type
		- the p flag in the descriptor indicates that the v-word 
		  contains a pointer to a block
		- some other blocks have varying sizes for other types, 
		  like records
		- a block will never grow or shrink in size
		- if the type code in the title does not determine the
		  size of the block, the second word in the block contains it's size in bytes
		- many blocks contain an id field that is used to
		  distinguish between different blocks of the same type
		  	- the runtime system maintains seperate id counters
		  	  for blocks of different types
		- blocks may contain descriptors as well as 
		  non-descriptors like qualifiers
		  	- an example is record blocks which may contain
		  	  different data types for each field
		- non-descriptor data comes first in a block before the
		  descriptor data
		- the first descriptor in a block is constant for all
		  blocks of a given type, which helps with garbage collection
	- Variables
		- variables are also represented with descriptors just 
		  like values
		- variables to identifiers point to descriptors for the 
		  corresonding values
		- variable descriptors never point to other variable 
		  descriptors, always to value descriptors 
		- the v flag indicates that the descriptor is for a 
		  variable
		- the values of local identifiers are kept on a program
		  stack while static/global identifiers are kept in fixed locations in memory
		- a variable that references some value in a data 
		  structure references the start of the data structure and the least significant bits of the d-word will contain an offset (in words, not bytes) to the value you want to reference
		- Operations on variables
			- variables can be used in 2 fundamental contexts
			  dereferencing and assignment
			- for example the instruction write(s) for some
			  string s calls for the variable descriptor s to fetch the value descriptor holding "hello" that it is pointing to. This is dereferencing
			- say you also want to assign s := 13570. The value 
			  descriptor pointed to by the v word of the variable descriptor changes
		- Special Variables
			- Icon has special variables that make dereferencing and assignment more complex
			- an example is keywords
				- &trace is always an integer value
				- Consider &trace =: expr
				- the result of expr must be type checked/converted to make sure it is an 
				  integer
				- if we want to perform this checking on each assingment to a keyword, it 
				  would require a lot of computation
				- instead Icon divides variables into 2 classes, ordinary and trapped
			- Ordinary variables point to a value and need no special processing
			- Trapping variables are distingiushed by a t flag to indicate that it needs 
			  special processing
			- Trapped Variables
				- recent versions of unicon do not use trapped variables
				- instead special keyword variables have different descriptor types than 
				  normal variables
				- however they are still used for assignment to substrings, and table elements
				- ex. procedure tabvar(n)
							...
							return tb[n]
							end

							tabvar(5) := 10 # is equal to tb[5] := 10
				- for this example it is impossible for the translator to determine that 
				  tabvar(5) returns a variable tb[5] 
				- In this case, trapped variables are used to handle weird shit like this
			- Keyword Variables
				- keywords have thier own types since they always require special treatment
				- most special cases need only special processing for assignment and not
  			  dereferencing
  - Descriptors and Blocks in C
 		- Often in order to understand the implementation of previously explained concepts
 		  in Icon, it is useful to look at the C code
 		- Descriptors in C
 			- when ints and pointers are the same size, the word size is the size of an int
			  and if a pointer is larger than an int the word size is long or long long
			- this difference in memory models is handled by typedefs under the control of 	
			  conditional compilation
			- so depending on the memory model the architecture follows, one of two
			  typedefs will compile, which will determine the word size, and define the "word" type
			- Descriptors are declared as structs 

				struct descrip{
					word dword; // type field

					union {
						word integr; 
						#ifdef DescriptorDouble
							double realval
						#endif
						char *sptr; // string ptr
						union block *bptr; // block pointer, type defined elsewhere
						struct descrip *dptr; // ptr to a different descriptor
					} vword // value field
				};

			- the union represents that the vword can be various different values, int, str 
			  pointer, block pointer, descriptor pointer
		- Blocks in C
			- each block type has a different struct declaration
			- ex record block struct

					struct b_record {
						word title;
						word blksize;
						word id;
						union block *recdesc; // ptr to record constructor
						struct descrip fields[1];
					}

			- record blocks vary in size so for now we declare the fields array to be 1 
			  descrip struct in size;
			- actual blocks for records are constructed at run time in some region managed 
			  by Icon's storage allocator
			- Icon blocks conform to the C blocks except for the number of fields
			- The C declaration provides a means of accessing portions of blocks from C
			- ex. substring trapped variable blocks

					struct b_tvsubs {
						word title;						// T_Tvsubs
						word sslen;						// length of substring
						word sspos;						// position of substring
						struct descrip ssvar; // variable that substring is from
					}
			- the title fields contain type codes defined as C macros
			- the block union given in the record declaration has all the block types

				union block {
					struct b_real realblk;
					struct b_cset cset;
					struct b_file file;
					struct b_proc proc;
					struct b_list list;
					struct b_lelem lelem;
					struct b_table table;
					struct b_telem telem;
					struct b_set set;
					struct b_selem selem;
					struct b_record record;
					struct b_tvsubs tvsubs;
					struct b_tvtbl tvtbl;
					struct b_refresh refresh;
					struct b_coexpr coexpr;
					struct b_externl externl;
					struct b_slots slots;
					struct b_bignum bignumblk;
				}

			- Note : there are other block types besides the source language data types
		- Defined Constants
			- type codes are defined symbolically as macros

				#define T_Null 0
				#define T_Integer 1
				#define T_Lrgint 2
				#define T_Real 3
				#define T_Cset 4
				#define T_File 5
				#define T_Proc 6
				#define T_Record 7
				#define T_List 8
				#define T_Lelem 9
				#define T_Set 10
				#define T_Selem 11
				#define T_Table 12
				#define T Telem 13
				#define T_Tvtbl 14
				#define T_Slots 15
				#define T_Tvsubs 16
				#define T_Refresh 17
				#define T_Coexpr 18
				#define T_External 19

			- d word flags also have defined constants

					n F_Nqual
					p F_Ptr
					v F_Var
					t F_Tvar

			- the d words themselves are defined as constants by bitwise expressions

				#define D_Null (T_Null | F_Nqual)
				#define D_Integer (T_Integer | F_Nqual)
				#define D_Lrgint (T_Lrgint | F_Ptr | F_Nqual)
				#define D_Real (T_Real | F_Ptr | F_Nqual)
				#define D_Cset (T_Cset | F_Ptr | F_Nqual)
				#define D_File (T_File | F_Ptr | F_Nqual)
				#define D_Proc (T_Proc | F_Ptr | F_Nqual)
				#define D_List (T_List | F_Ptr | F_Nqual)
				#define D_Table (T_Table | F_Ptr | F_Nqual)
				#define D_Set (T_Set | F_Ptr | F_Nqual)
				#define D_Selem (T_Selem | F_Ptr | F_Nqual)
				#define D_Record (T_Record | F_Ptr | F_Nqual)
				#define D_Telem (T_Telem | F_Ptr | F_Nqual)
				#define D_Lelem (T_Lelem | F_Ptr | F_Nqual)
				#define D_Tvsubs (T_Tvsubs | D_Tvar)
				#define D_Tvtbl (T Tvtbl | D_Tvar)
				#define D_Coexpr (T_Coexpr | F_Ptr | F_Nqual)
				#define D_Refresh (T_Refresh | F_Ptr | F_Nqual)
				#define D_Var (F_Var | F_Nqual | F_Ptr)
				#define D_Tvar (D_Var | F_Tvar)

		- RTL Coding
			- the optimizing compiler was introduced later in Icon (version 8/9) so the 
			  routines for the runtime system use an extended C syntax called the RTL (Run-Time Language)
			- operator{} is a construct that doe smultiple things
				- the first is to declare a C function that the interpreter will call
				- operator{1} * size(x) declares a C function size() for the * operator
				- the arguments and results are descriptors
			- RTL extends C's return statement to include type information, which allows
			  the d-word of the return value to be changed the appropriate type
			- RTL's type_case is like a switch statement which executes different code 
			  based off the type of the input

Strings and Csets
	- in Icon, strings are the most common data type used
	- therefore storage and access of string data is necessary
	- also the efficiency of frequently used operation is important like *
	- string lengths are determined dynamically during execution
	- the automatic storage management of strings in Icon is what gives much of the
	  advantage to Icon for string processing 
	- any of the 256 8-bit ASCII characters can be represented even the NULL character
	- several Icon string operations retun substrings of a string 
	- Icon strings are atomic, meaning that three are no string operations in Icon that
	  change the characters in existing strings
	- this is not obvious, there are operations that appear to change the characters 
	  in strings, but they don't
  - the atomic nature of strings simplifies the implementation 
  	- an example would be the assignment of a string value to a variable 
  	- the string value is not copied in this case since the string will not change
 	- the order of the characters in a string is very important, csets are provided 
 	  when several characters have the same status and the order is not relevant

 	- Representation of Strings
 		- C represents strings as arrays of characters as successive bytes in memory
 		  terminating in a null byte
 			- a disadvantage of this is that you need to index through the string to find 
 			  it's size
 			- since every string in C terminates with a null byte, substrings cannot exist 
 			  within strings
 		- Icon does not use null characters, therefore there must be some external way to
 		  determine the end of the string 
 		- this is the motivation for the qualifier representation
 			- the qualifier includes the address of the first character and it's length
 		- this representation (with no null char) allows for quick computation of 
 		  substrings
 		- Note : C style strings can be utilized by Icon since qualifiers can easily 
 		  handle C strings, but C cannot utilize Icon strings without copying and appending a \0
 		- Some strings are compiled at runtime, while others like string literals can be 
 		  contained in the icode
 		- during execution, strings may be stored in work areas (usually buffers)
 		- when new strings are created during execution, they are allocated in a common 
 		  string region
 			- when source-code operations create a new string, its characters are appended 
 			  to the end of the strings already in the common string region
 			- the string region will continue to fill up until it is full and it has to be 
 			  compacted by the garbage collector, which sweeps away unneeded chars

 		- Concatenation
 			- ex. 
 					s1 := "ab" || "cdef"
 				- in this example the concatenation operation allocates a space for 6 chars 
 				  and it copies the 2 strings into that space, which is assigned a qualifier s1
 			- there are important optimization cases for concatenation
 				- if the first argument is the last string in the string region, then the
 				  second argument is appended to the end of the string region
 					- so 
 							s := s || str 

 							will perform less allocation than

 							s := str || s

 				- if the strings being concatenated are already adjacent in the string region 
 				  then you dont have to do anything
 				- other than that string construction operations will never use another
 				  instance of a string that may exist elsewhere in the string region  
 			- RTL code for concatenation

 				operator{1} || cater(x,y)
 				if !cnv:string(x) then
 					runerr(103, x)
 				if !cnv:string(y) then 
 					runerr(103, y)

 				abstract {
 					return string
 				}
 				body {
 					CURTSTATE();

 					/*
 					 * Optimization 1: Strings are adjacent in string region, no allocation
 					 */
 					if(StrLoc(x) + StrLen(x) == StrLoc(y)) {
 						StrLoc(result) = StrLoc(x);
 						StrLoc(result) = StrLen(x) + StrLen(y)
 						return result
 					}

 					else if ((StrLoc(x) + StrLen(x) == strfree)
 					&& (DiffPtrs(strend, strfree) > StrLen(y)) {

 					/*
					 * Optimization 2: The end of x is at the end of the string space.
					 * Hence, x was the last string allocated and need
					 * not be re-allocated. y is appended to the string
					 * space and the result is pointed to the start of x.
					 */
					result = x;

					/*
					 * Append y to the end of the string space.
					 */
					Protect(alcstr(StrLoc(y),StrLen(y)), runerr(0));

					/*
					 * Set the length of the result and return.
					 */

					StrLen(result) = StrLen(x) + StrLen(y);
					return result;
						}

					/*
					* Otherwise, allocate space for x and y, and copy them
					* to the end of the string space.
					*/
					Protect(StrLoc(result) = alcstr(NULL, StrLen(x) + StrLen(y)), runerr(0));
					memcpy(StrLoc(result), StrLoc(x), StrLen(x));
					memcpy(StrLoc(result) + StrLen(x), StrLoc(y), StrLen(y));

					/*
					 * Set the length of the result and return.
					 */
					StrLen(result) = StrLen(x) + StrLen(y);
					return result;
					}
				end

		- Substrings
			- ex. 
					s2 := s1[3:6] # s1 --> "abcdef"
				- this operation does not actually allocate a new string
				- the operation actually porduces a new qualifier which points to the 
				  beginning of the substring and includes the size of the substring
				- in this example the substring would point to c and have a contain a size of 
				 3
			- this allows substrings to be retrieved while maintaining the characters in  
			  original string 
			- Again the difference between C strings and Icon strings is that Icon strings 
        are atomic, immuatable, indivisible objects, while C strings are arrays of chars
      - there are operations that appear to change the chars of a string 
      	- ex.
      			s1[3] := "x"

      			is the same as 

      			s1 := s1[1:3] || "x" || s1[4:0]
      		- a new string is created from the concatenation
 					- this type of operation opens up the possibility to change the length of a 
 					  string by assignment to a substring,
 					  - ex.
 					  		s1[3] := "xxx" ---> s1[3] := s1[1:3] || "xxx" || s1[4:0]
 					  		s1[2:5] := "" --->  s1[1:2] || "" || s[5:0]

 		- Assignment to Subscripted Strings
 			- first off x[i] and x[i:j] are more complicated in Icon than they may appear
 			- the translator cannot determine the type of x in the first place
 				- x may be a string, list, table, or record
 				- also the operation performed is different for different types
 			- the translator also cant determine if a subscript expression is performing 
 			  assignment or dereferencing
 			  - ex. 
 			  		write(s[2:5])    # dereference
 			  		s[2:5] := "xxx"  # assignment
 			- the solution is trapped variables, also used for keywords
 				- a substring trapped variable has a t flag and the typecode tvsubs, with a 
  			  pointer to a block that contains another typecode tvsubs, the length, the offset and another pointer to a qualifier that represents the string
  			- Note : the trapped variable substring block and the 
  			  variable descriptor both point to the same qualifier, which makes it possible for assingment to a substring to change the actual string held by the variable 
  			- the length and offset of the substring varible block is 
  			  what allows for the production of a qualifier for the substring
  			- so since the variable block and the original variable 
  			  qualifier point to the same string, if the value of the substring is changed by through assignment 
  			  (concatenation), the string value stored in the original variable qualifier will also change
  				- ex. 
  					s := "123456"
  					s[2:4] := "x"
  					write(s) # --> prints "1x456"
  			- after substring assignment the length of the subscripted
  			  portion of the string will change to reflect the length of the string that was assigned to it

  		- String Mapping
  			- Recall map() usage :
  				ex. write(map("01234", "43210", "abcde")
					-> returns "edcbe" 

  			- The mapping is done using the character array maptab.
  			- the array is created by first assigning every possible
  			  character to its own position in maptab (0 -> 255)
  			  	- maptab[i] = i
  			- then for each character in s2, the position in 
  			  maptab corresponding to the value of that character in s2 is assigned the value of the character in s3 that has the same position
  			  	- Note : s2 and s3 are &ucase, &lcase by default
  			  	- maptab[s2[j]] = s3[j] 
  			  	  # where j - range(0, len(s2)) 
  			- to avoid rebuilding maptab this step can be skipped if the
  			  previous map call used the same s2 and s3. the global variables maps2 and maps3 hold the cached values
  			- Now that the maptab is built, you can run through s1 and 
  			  map out the new string using the maptab array
  				- while(slen-- > 0)
  				      *str2++ = maptab[*str1++]
  	- Csets
  		- there are a possible 256 different characters that can occur 
  		  in csets
  		- cset blocks consist of the title, number of characters
  		- next in the block comes a bunch of words, containing a total 
  		  of 256 bits, with each bit in each word representing 1 character
  		  - for a wordszie of 32 bits, then the words are 8 bits and 
  		    there will be 32 words in the cset block other than the title and length
  		- if the bit is set, then it is present in the cset, if not, it 
  		  is not present in the cset 
  		- cset block C structure
  			
  			struct b_cset {
  				word title;
  				word size;
  				unsigned int bits [CsetSize]
  			}

  		- CsetSize is the number of words it takes to add to 256 bits
  		- not very many programs use the size of the cset so the size
  		  field is initially set to -1 and the actual size is computed if its needed
		- cset operations are fairly straighforward
		- the characters in a cset are represented by a bit vector of 
		  bits divided into words

Lists
	- most programming languages provide an array or vector data type to 
	  access data elements by position
	- icon lists are different becuase they are constructed during
	  runtime rather than during compile time
	- this means that the size of the list is not known until runtime
	- a list value is actually a descriptor that points to a block
	  structure that holds the elements
	- so lists are passed by reference in this way
	- the biggest implementation issue of lists is their ability to grow
	  and shrink through the stack and queue operations		

	- Structure of Lists
		- a list consists of a fixed size list-header block
		- a list-header block contains...
			- title
			- current size of the list
			- block pointers that point to the first and last blocks of 
			  a doubly-linked chain of list-element blocks that contain the actual list elements
		- list element blocks vary in size
		- C struct for list header block

				struct b_list { /* list-header block */
					word title; /* T_List */
					word size; /* current list size */
					word id; /* identification number */
					union block *listhead; /* first list-element block */
					union block *listtail; /* last list-element block */
				};

		- a list-element block contains...
			- title
			- size of block in bytes
			- 3 words used to determine the location of the elements in the the block
			- block pointers that point to the next and previous list-element blocks
			- slots for elements
		- C struct for list-element block

				struct b_lelem { /* list-element block */
					word title; /* T_Lelem */
					word blksize; /* size of block */
					word nslots; /* total number of slots */
					word first; /* index of first used slot */
					word nused; /* number of used slots */
					union block *listprev; /* previous list-element block */
					union block *listnext; /* next list-element block */
					struct descrip lslots[1]; /* array of slots */
				};
		- when a list is initialized in the source code there is only one list element 
		  block, others are added to the chain with pushes or puts
		- list element blocks have a minimum number of slots which allows for extra room 
		  when adding new elements to lists that grow over time list adding an empty list that will grow later
		- Normally the minimum number of slots is 8
		- put() adds an element to the end of the list
		- push() adds an element to the front of the list
		- Note: since the slots are a circular doubly linked list, what keeps track of
		  the front of the list is the information contained in the header of the list-element block that keep track of the number of total slots, the first slot used, and the number of slots used. it may appear as though the list elements do not appear in the correct order but they are correct
		- when you remove an element, it does not shorten the list-element block or
		  overwrite anything, it just becomes inaccessable
		- In the case of a list-element block slots becoming full, then a new block is 
		  allocated and linked in
		- the size of the new block is either half the number of elements in the entire
		  list, or MinListSlots
		- Unicon imposes an upper limit MaxListSlots
		- looking at diagrams in book makes it much more clear
		- If a block has all of it's elements removed, it will still be linked to the 
		  other blocks (first slot used will be 0)
			- this is to ensure that there is always at least 1 list-element block even if 
			  the list is empty
			- the only time when a list-element block is removed is when an element is
			  removed from a list in which the chain contains an empty list-element block, then you can remove the empty block

	- Positional Access
		- to get a[i] it requires locating the correct list-element block
		- if a list has several LE blocks then you have to link through the blocks while
		  keeping track of how many elements you've seen until you find the i'th element
		- a[i] will return a variable descriptor that points to the right slot in the LE 
		  block

	- Array Access (Unicon only)
		- Unicon offers an optimzed special list structure for fast access to list 
		  elements
		- a unicon array is a list where all the elements are the same type and are in a 
		  single block, all contained in consecutive slots
		- since all the elements are the same type, they can be accessed very fast by 
		  indexing
		- if any operation is performed on an array that would only be able to be
		  performed on a list it is converted to one
			- an example would be push(), put(), replacing an element for one of a 
			  different type, etc

Sets and Tables	
	- sets and tables are data aggregates that few languages support
	- the main reason that these data types do not exist in many lnaguages is because 
	  of the difficulty of implementation
	- sets support the common mathematical operations that you find over finite sets
		- union, intersection, difference, removal, insertion, membership
	- sets in Icon can contain members of any type
	- there are many attributes of sets that cause the implementation to become more
	  difficult
		- heterogeneity of members
		- ability to grow/shrink
		- efficient access
		- insertion and deletion of members
		- arbitrarily large sets
	- tables on the other hand have more structure
	- a table is a set of pairs that represents a many-to-one relationship function
	- programmers use them more literally, using them to tabulate a set of values

	- Sets
		- Data Organization for sets
			- hash lookup and linked lists are used to provide an efficient way of 
			  locating set members
			- for every set, there is a set header block that contains...
				- a word for the number of elements in the set
				- slots that serve as heads of linked lists of set-element blocks
			- So the way that data is stored in sets is with a hash table
				- the hash table is split up into segments with the first segement having
				  the least number of slots and the following segments each being twice as large as the last
				- the reason for this is because small tables benefit from reduced memory 
					and large tables have better performance
				- each set element is stored in a set-element block
					- set element blocks are the nodes in the linked lists and they contain...
						- a desriptor for it's value, the hash number and a pointer to the next 
						  node
				- whenever an element is looked up, a hash number is computed from it's value
					- the hash function is --> 8 * golden ratio * value
				- the absolute value of the remainder resulting from dividing this hash
				  number by the number of slots is it's spot in the hash table
				- the hash number of the value being looked up is compared with the hash 
				  numbers on the set-element blocks
				- If there is a match, the values may or may not be the same, since 
				  collisions are unavoidable. but it is necassary now to compare the values to determine if they are the same
				- the set-element block nodes are ordered by their hash numbers, so that
				  when the linked list is being examined, the search stops if the hash number of an element on the list is greater than the hash number of the
				  value being looked up
				- when the lookup is for the purpose of insertion, then if the value is not 
					found, then a new set-element block is allocated and inserted into the list
		- Set Operations
			- union, intersection, and difference all produce new sets and do not modify 
			  their arguments
			- union
				- a copy of the larger set is made first, includes set-header and all 
				  set-element blocks, no lookups required
				- then each element in the smaller set is inserted by lookup
				- the insertions may take longer however since the linked lists may be longer
			- intersection
				- a copy of the smaller set is made and any member that is not in the larger 
				  set is omitted
			- difference
				- a copy of the first argument set is made, adding only elements that are 
				  not in the second argument set
				- involves looking up all arguments of the first set in the second

	Tables
		- similar to sets with an added default value descriptor in the table-header 
		  block
		- table lookup is more complicated then set lookup since table elements can 
		  contain both an entry value and an assigned value (key, value pair)
		- also table entries can be referenced by either value
		- a table element block contains...
			- pointer to next table element block node in the list
			- the hash number
			- the entry value descriptor
			- the assigned value descriptor
		- table reference t[x] uses x as the hash parameter to compute a hash value and 
		  select a slot
		- the corresponding list is then searched for the block that contains the same 
		  entry value
		- in sets the values are compared only if the hashes are the same
		- if a matching entry value is found then a variable descriptor is created that
		  points to the corresponding assigned value
		  - this is done so that the assigned value can be used in assignment/
		    dereferencing
		- if a matching entry is not found, then either, the default value is returned 
		  (dereferencing), or a new element is added to the table (assignment)
		- this is done through trapped variables like with substrings

		- Hash Functions
			- ideally a hash function should return a different hash value for 
			  each input
			- also for the Icon set/table has function the remainder produced
			  from dividing the hash by the number of slots should have a uniform distribution
			- this ideal hash function would require an unreasonable amount of 
			  storage and comuptation
			- hash computations have been studied extensively and in general
			  lookup time and storage overhead are inversely propotional
	
The Interpreter
	- the interpreter is the software realization of Icon's VM
	- stack based
	- the basic units of the VM are descriptors
	- instructions for the interpreter consist of operations that 
	  manipulate the stack, call C functions that carry out built in functions and manage flow control.
	- the interpreter consistes of a loop in which a VM instruction is
	  fetched and control is transferred to a section of code that can execute the corresponding operation

	- Stack-Based Evaluation
		- VM instructions typically push/pop data off the interpreter 
		  stack
		- the interpreter stack is distinct from the C program stack
		- the interpreter stack is an array of words
		- the variable "sp" points to the last word pushed to the stack, 
		  i.e. the top of the stack 
		- pushing increments sp by 1 word, while popping decrements sp by 
		  1 word
		- when the interpreter calls a built in operation, it pushes the 
		  arguments onto the stack as descriptors
		- then the corresponding C function is called with a pointer to
		  the place on the interpreter stack where the arguments begin
		- a null argument is pushed first to serve as the zeroith 
		  argument or Arg0
		- Arg0 will hold the return value of the C function so that when 
		  the C function returns, Arg0 will be at the top of the stack
		- Normally for more conventional virtual machines, the result 
		  would be pushed to the stack via a push() operation, but returning the value as an argument is better for Icon
		- ex.
			Consider the expresion ?10
			the corresponding VM operations are ...
			pnull		# push null
			int 	10  # pushdescriptor for 10
			random		# compute random value

			the first 2 instructions operate on the stack while the third instruction calls a C function

	- Virutal Machine Instructions 
		- every aspect of Icon expressions in the source code are
		  reflected either directly or indirectly, in the Icon VM instruction set
		- the same should be said for constants, identifiers, and  
		  operators
		- the meaning of an operation is fixed and cannot be changed
		  during execution		
		- however, the meaning of a function call cannot be determined 
		  until it is evaluated
		- there is one instruction for function invocation
		- many VM instructions are specific to control structures and the unique
		  expression evaluation of unicon

		- Constants
			- 4 types of literal data types
				- integers, strings, csets, real numbers
			- the 4 corresponding VM instructions are ...
				- int 	n 		# integer n
				- str 	n, a 	# string of length n at addr a
				- cset  a 		# cset block at addr a
				- real  a     # real block at addr a
			- the value of an integer literal appears as an argument of the "int" 
			  instruction
			- the arguments of the "str" instruction holds the length and addr of the 
			  string
				- the actual string is constructed by the linker and loaded into memory from 
				  the icode file
			- for csets and blocks, the linker will construct the blocks loads them into 
			  memory from the icode file
				- these blocks are identical ot the blocks that are constructed during
				  program execution
			- the VM instructions "str", "int", and "cset" push appropriate descriptors
			  onto the VM stack to reference the data as it appeas in the icode
			- ex.  ?"aeiou"

					the corresponding VM instructions would be ...

					pnull				   # push Arg0
					str      5, a  # create and push a qualifier descriptor from <5, a>
					random			   # get a random character

					The value produced by the random instruction will replace the null descriptor

			- Identifiers
				- from the interpreter's perpsective, there are 4 different types of 
				  identifiers
				 	- global, static, local, arguments
				- global and static identifiers are kept in arrays located at some fixed 
				  memory location
				- local identifiers and arguments are kept on the stack as part of the data
				  that is associated with a procedure call
				- when a procedure is called ... 
					- the values of the arguments are pushed on to the stack first
					- then the local identifiers for that procedure are pushed with an initial 
					  null value
					- there is a fixed section of the stack in between the arguments and the 
					  local identifiers that contains information that is saved when a procedure is called. The information is explained later on
				- There are 4 VM instructions for constructing variable descriptors
					- global		n
					- static 		n
					- arg 			n
					- local 		n
				- identifiers are indexed starting from 0
				- ex.
						arg 		0 # pushes a variable descriptor for the first argument
				- in every case, the descriptor that is pushed, is a variable descriptor 
				  that points to the value descriptor for the corresponding identifier
				- ex. Assingment
						j := 1

						the corresponding VM instructions are ...

						pnull 				# push null descriptor
						local 		2   # push variable descriptor for j
						int 			1   # push descriptor for integer 1
						asgn          # assignment of 1 to variable j

				- Note : assign will assign the value (2nd arg) to the variable (first arg) 
				  and it will overwrite Arg0 with a variable descriptor which points to the local value descriptor contained further down the stack. so at this point the top of the stack points to the variable descriptor

				- ex. Assignment 2
						z := x
						 the corresponding VM instructions are ...
						 
						 pnull			  # push null descriptor
						 local 		0   # push z variable onto stack (first arg to asgn)
						 arg 			0   # push x variable (second arg to asgn)
						 asgn 				# do assignment

				- Operators
					- each of the 42 different operators has a different VM instruction
					- random / asgn from the previous sections are examples
					- very few of the Icon operators are simple
						- for example x + y requires doing type checking/conversion on x and y,
						  and throwing an error if the addition is not possible
						- also what if x is an int but y is a floating point, in this case x is
						  converted to a float  
						- the complexity is not evident for the VM instructions for add which is 

								pnull
								local 		x
								local 		y
								plus

						- in the previous VM instruction examples the indices used to access
						  identifiers are now replaced by the names of the identifiers which are assumed to be local
							- this is for ease of reading?
						- in the case of augmented assingment operations, ex. -> (i +:= 1)
							- these do not have their own VM instructions, instead the "dup" 
							  instruction first pushes a null descriptor and then pushes a duplicate descriptor that points to the same variable as the descriptor that was on the top of the stack before
							- so the stack would read 

								null descriptor
								local i        --------> i 
								null descriptor   |
								duplicate 		 ----

							- the dup instruction essentiall takes the place of a second

								pnull
								local i

							- what about the case of a more complicated augmented assignment?
							- ex. a[j] +:= 1 
							- the duplication now saves a lot more computation

				- Functions
					- the meaning of an operation is fixed and can be translated into a 
					  specific Vm instruction
					- the meaining of a function call can change during execution so it cannot 
					  be understood at translation time
					- the value of a function can be computed as in
						- (p[i])(x, y)
					- the general form of the call is
						- expr0(expr1, expr2, ... exprn)
						- the corresponding VM instructions

						code for expr0
						code for expr1
						code for expr2
						...
						code for exprn
						invoke n
					- the invoke instruction is kinda complex, since expr0 could be a 
					  procedure, an integer (mutual evaluation) or an erroneous value
					- invokation is discussed later on
				- Self-Modifying Instructions
					- there are seven opcodes, some of which have already been mentioned, that
					  contain operands whose values are addresses wihtin the VM icode
					- the linker cannot know these runtime addresses, so instead it generates 
					  the instructions with byte offsets, relative to the current instruction
					- at runtime, the interpreter obtains the addess of the instruction by 
					  adding the current instruction pointer to the offset
					- after one of these instructions is encountered by the interpreter, it adds the offset and stores the actual pointer in the offset field and modifies the opcode
					- the self modifying instructions and their address holding counterparts 
					  are as follows ...
					  
					  	str 				Astr
					  	cset 				Astr
					  	real 				Areal
					  	global		  Aglobal
					  	static      Astatic
					  	goto 				Agoto
					  	mark 				Amark 

					- the first 4 instructions (str, cset, real, global) push a descriptor for 
					  their respective values onto the stack
					- goto sets ipc to offset n
					- mark creates an expression frame
					- the addresses of the operands of each of these types in some way, 
					  cannot be known during translation
					- therefore the linker will generate the instruction with the offset in
					  order to locate the addresses of the values
					- in each case the opcode and the offset operand are changed, thus
					  self-modification
					- the self-modification is done through 2 "put" macros
						- PutOp(Op_Astr) on the current opcode
						- PutWord(opnd)
						- or, if the IP is referring to the operand, PutInstr(Op_Astr, opnd, 2)
					- the self modifying instructions create a race condition which needs to 
					  be protected by mutexes

	- The Interpreter Proper	

		- The Interpreter Loop			 
			- the interpreter, called interp() is not that complicated
			- it maintains an icode instruction pointer called "ipc"
				- I assume it stands for icode program counter
			- the interpreter starts by fetching the instruction through the ipc and then 
				incrementing ipc to the next location
			- then it branches to some section of code that processes the VM instructions 
			  that it fetched
			- /runtime/imain.r has the main interpreter code 
			- Here is the interpreter loop ...

					for (;;) {
						op = GetWord;

						switch(op){
						...
						case Op_Asgn:
						...
						case Op_Plus:
						...
						}

						continue;
						...
					}

			- GetWord is a macro defines to be (*ipc++)
			- macros are used A LOT in the interpreter to avoid repetition in code
			- ex. instruction "plus"

				case Op_Plus: /* e1 + e2 */
					Setup_Op(2);
					DerefArg(1);
					DerefArg(2);
					Call_Op;
					break;

			- Setup_Op(n) sets up a pointer to the address of Arg0 on the interpreter stack
			- the value of n is the number of args on the stack
			- DerefArg(n) dereferences arg n, if it's a variable, it is replaces by that 
			  variables value
			  - dereferencing is done in place by changing descriptors on the stack
			- Call_Op / Call_Cond calls the corresponding C
			instruction with a pointer to Arg0 provided by Setup_Op()
			- the actual op function pointer is retrieved from an array of pointers to functions
			- if the C function returns a result, it is placed in Arg0, the interpreter adjusts sp to point to the return value, the switch statement breaks and the loop is started from the top to fetch another instruction
			- some VM instructions have operands which follow the icode insturction
			- ex.
				 int n
			- the interpreter code for instructions with operands will fetch the operands before calling the C function
			- ex. interpreter code for int

				case Op_Int:
					PushVal(D_Integer);
					PushVal(GetWord);
					break;

			- PushVal(x) pushed x onto the interpreter stack. 
				- We want to push the descriptor onto te stack, not the actual value so we first push the dword (PushVal(D_Integer)) then the v-word (PushVal(GetWord))
				
	- Interpreter State Variables
		- the state of the interpreter is described by variables called i-state variables
		- the two already mentioned are sp, the interpeter stack pointer and ipc, the interpreter program counter
		- the interpreter can push frames onto the stack that are like C funtion stack frames
			- the frames contain information (mostly i-state variables) that is saved when a procedure is called and updated when it is returned
		- there are special frames for some aspects of expression evaluation (Chapter 9)
		- pointers to frames are i-state variables
		- maintaining all the i-state variables is central to the interpreter

Expression Evaluation
	- in the previous chapter the focus is on the interpreter and the expression evaluation is presented conventially wherin every expression gives exaclty one result
	- an example is assignment a := 10
		- this cannot fail or produce a sequence of results
	- in Icon the expression evaluation mechanism has the capacity to produce many results or none at all for any expression
	- this results in a lot of unconventional program flow which require unconventional methods to control that flow
	- this aspect of the expression evaluation sets Icon apart from other programming languages
	- Generators are not a feature exclusive to Icon, even at the time of it's release, however, Icon generators are not limited to certain contexts, constructs, or data types
	- these reasons make Icon's expression evaluation one of the most difficult aspects of the implementation

	- Bounded Expressions
		- a bounded expression is one in which backtracking can take place, but once it produces a result it cannot be resumed
		- ex. 
				write(i = find(s1, s2))

				# find may produce a result but if the comparison to i fails, 
				# it will resume until it finds a match to i
				# then write will print i and cannot be resumed
		- so once i = find(s1, s2) produces a result, it cannot be repeated
		and it will have no effect on other expressions
		- ex. 

			write(i = find(s1, s2)) & write(j = find(s1, s3))

			# these expressions are combined into 1 and expr2 is not 
			# evaluated unless expr1 suceeds and if expr1 succeeds but expr2 
			# fails expr1 is resumed

		- there are 2 cases for this expression
		- the translator will insert a semicolon at the end of every expression which bounds the expression and the conjunction operator & binds it's operands into a single expression
		- a procedure is seperated into a number of bounded expressions by semicolons (impicit/explicit)
		- this is important because if a procedure was just a single expression then the failure of one subexpression would propagate through the procedure body
		- Note : for these notes i will denote bounded expressions with <||>
		- instead control backtracking is limited in scope to each bounded expression as well as the lifetime (and hence stack space) for temporary computations
		- in control structures this is important

			if <|expr1|> then expr2 else expr3

		- expr2 or expr3 may be part of a larger bounded expr
		- ex.
				write(if <|i < j|> then i to j else j to i)
		- if expr1 was not bounded then the failure of expr2/3 would backtrack into expr1, and the conditional would be equivalent to

			(expr1 & expr2) | expr3

		- this is not the same as if-then-else
		- while loops 

			while <|expr1|> do <|expr2|>

		- both the body and conition are bounded
		- this ensures that each expression does not inferfere with each 
		other or the surrounding context
		- if expr2 fails it wont backtrack into expr1

		- Expression Frames
			- the scope of backtracking is supported by expression frames
			- the VM instruction ...

					mark L1

				starts an expression frame
			- if the following expression fails, ipc is set to the icode location of L1
			- the value of ipc for a label is relative to the location of the icode that 
			  is read from the icode file
			- mark pushes an expression frame marker onto the stack and sets the expression frame pointer (efp) to it
			- the efp indicates the current position of the current expression frame
				- also there is the gfp (generator frame pointer) which points to another 
				  kind of frame that is used to retain info for when an expression suspends with a result and it is possible to resume it to get another result
			- mark sets the gfp to 0 since there is no suspended generator for a new expression frame
			- an expression fram marker has 4 words
				- the value pointed to by ipc (argument of mark, called failure ipc)
				- the previous efp
				- the previous gfp
				- ilevel (related to suspended generators)
			- the failure ipc is essentially the stack position the control goes to if 
			  the current expression fails
			- unmark is the VM instruction that removes an expression frame
				- unmark restores the previous efp/gfp from the current expression frame
				  marker
				- then it removes the current expression frame by setting sp to the word 
				  above the frame marker
			- ex.
					if expr1 then expr2 else expr3

					VM instructions
							mark L1
							**code for expr1**
							unmark
							**code for expr2**
							goto L2 
					L1:
						**code for expr3**
					L2:

			- mark create an expression frame for expr1
			- if expr1 gives a result then unmark the frame for expr1 and go into expr2
			- if expr1 fails then control goes to the icode corresponding to L1 and unmark 
			  is not executed 
			- if there are no generators the failure ipc removes the current expression
			  frame
			- remember the previous efp must be saved in a new expression marker for
			  nested expression frames

		- Failure
			- expression evaluation can be divided into 2 cases, with/without generators
			- for this section we will not include generators
			- without generators, if failure occurs anywhere in an expression the entire 
			  expression fails without and further evaluation
			- ex. 
					i := numeric(s)
					# if numeric(s) fails there will be no assignment and 
					# control goes to next line		

			- in the implementation, failure of an expression amounts to removing the 
			  current expression frame where the failure is taking place and continuing with the ipc set to the failure ipc from it's expression frame marker
			- ex. VM instructions from previous example
					mark L1
					pnull
					local i
					global numeric
					local s
					invoke 1
					asgn
					unmark
					
					L1:
						...
			- Now before the first expression is evaluated there is some expression frame
			  on the stack
			- mark L1 pushes a new expression frame and assigns the previous efp
			- the next instructions push additional descriptors
			- then invoke is called and numeric is called
			- if numeric fails then efp and sp are reset to the previous values so that 
			  the stack is in the same state prior to the beginning of the expression evaluation
			- L1 contains the starting icode position of the next instruction
			- so if numeric succeeds control will transfer to L1 
			- failure occurs at 3 levels
				- the VM instruction efail
				- a C function that implements some Icon operator or function
				- an Icon procedure
			- when a conditional operator (&, <, >) or function returns it signals the
			  interpreter using an one of the RTL returns : return or fail
			- these RTL contructs just return statements with different returned values
			- the interpreter code for a conditional variable is basically...
				- dereference arg1
				- dereference arg2
				- Call_Cond
			- Call_Cond is like Call_Op but it tests the singal returned by the C RTL function
				- if the signal indicates that an result is produced, the control breaks in 
				  the interpreter switch statement and the interpreter loop begins with the next instruction
				- if the signal indicates failure, control is transferred to the place in 
				  the interpreter that handles failure efail
			- an Icon procedure can fail in 3 ways ...
				- evaluating the expression "fail"
				- the failure of the argument of a return expression
				- flowing off the end of the procedure body
			- The VM instructions for each case are similar
			- the pfail VM instruction first fails the current procedure then transfers control to efail

		- Generators and Goal-Directed Evaluation
			- generators contribute to the real power of Icon/Unicon's expression evaluation mechanism
			- there are generators for control structures, operators, functions, procedures
			- the same principles apply to all of them
			- as far as returning a result from an expression goes, the process is the same for expressions that produces a result and expressions that produce a result and are capable of producing another result
			- in general, prior to runtime, the translator cannot determine the difference between expressions and generators
			- the implementation is designed so that the interpreter stack is the same for enclosing expressions for expressions that return and expressions that suspend
			- if a generator has resumed, it must also be capable af being resumed
			- ex. 

				j := (i < upto('aeiou', "Hello World"))

			- when upto() suspends, both i and the result of upto() have to be on the stack as arguments of the comparison. but ifthe comparison fails and upto is resumed, the arguments of upto() must also be on the stack as they were when the generator suspended
			- in order to satisfy all those conditions, a part of the stack  (that contains stuff before the arguments of upto()) is copied to the top of the stack, after upto() suspends
			- then the result of upto() is pushed to the top of the stack
			- this preserves the state of upto()
			- the copied portion of the stack is the generator frame

			- Generator frames
				- generator frames contain a copy of a portion of the stack that is needed to resume the generator later
				- generator frames are started with a generator frame marker
				- there are 3 different kinds of generator frames which each have their own code
					- G_Csusp : suspension from C function
					- G_Esusp : suspension from alternation expression
					- G_Psusp : suspension from procedure
				- for G_Csusp and G_Esusp the information saved in the generation frame marker includes...
					- the code for the type of generator
					- the i-state variables efp, ipc, and gfp
					- the source program line number when the generator is initialized
				- Generators that do procedure suspension also have the procedure i-state variable
				- ex. 

						write(i = (1 to 3))

						the VM instructions would be 

							mark L1
							global write
							local i
							pnull
							int 1
							int 3
							push 1 # default increment
							toby
							numeq
							invoke 1
							unmark
						L1 :

				- when toby is called the stack contains the expressio frame marker -> write global identifier -> Arg0 for numeq -> local i descriptor -> Arg0 for toby -> int 1 -> int 3 -> int 1
				- then the RTL function Otoby(dptr r_args) is called with a pointer to the toby Arg0
				- Otoby() places the first number (1) into Arg0 and suspends
				- then suspend calls interp() instead of returning to it
				- so the toby call remains intact as the calling expression while transferring control to interp()
				- when interp() is called it builds a generator frame marker, and copies the stack section of the calling expression to the top of the stack so interp() can continue it's exeuction in it's recursive call
				- for the above example, after the numeq expression is copied, the comparison either fails or succeeds.
				- if there wasnt a generator frame and the expression failed, it would just be taken off the stack, but because of the generator frame, the stack is restored to its state before calling the generator
				- the way it does this is by returning the recursive interp(), with the signal A_resume which will actually resume the generator upto
				- now toby is called again, increments Arg0 to 2 and suspends which calls interp() again, and the comparison is made 
				- if the expression (numeq) succeeds, the recersive interp() returns with a signal that tells the interpreter to unmark the whole expression from the stack including the generator call
				- the interpreter loop then moved on to the next instruction

			- Goal-Directed Evaluation
				- goal directed evaluation happens when an expression fails and there are generator frames on the interpreter stack as a consequence of suspended expressions
				- ex.

						1 to upto(c,s)

				- this expression has 2 generators, one for upto and one for toby
				- these generator frames are linked where the gfp points to toby and toby has a pointer that points to the gfp for upto
				- this results in a LIFO order of expression evaluation
				- so goal-directed evaluation occurs as a side-effect of resuming a suspended expression when failure occurs in the surrounding expression frame
			
			 - Removing C Frames
			 	- C functions that suspend call the interpreter and the interpreter in turn calls C functions
			 	- So expression evaluation especially with generators typically results in a LOT of stack frames on the C program stack
			 	- when a bounded expression completes, there might be generator frames on the C stack that cannot be resumed
			 	- this is the purpose of the ilevel i-state variable
			 	- it keeps track of the call level of interp() by C functions
			 	- whenever interp() is called ilevel is incremented and saved in the current expression frame
			 	- whenever an expression frame is about to be removed, if the current ilevel is greater than the value in the expression frame, ilevel is deremented, and interp() returns with a signal to it's calling C function
			 	- if the signal is A_Resumption the C function continues, otherwise it returns
			 	- since C functions always return to interpt(), interp() will always check the signal returned to it to see if the C function returned a result or is unwinding
			 	- if it's unwinding, interp() returns the unwinding signal instead of continuing evaluation of the current expression
			 	- ex. again

			 			write(i = (1 to 3))
				
				 			mark L1
							global write
							local i
							pnull
							int 1
							int 3
							push1 # default increment
							toby
							numeq
							invoke 1
							unmark
						L1 :

				- when toby suspends a result it calls interp()
				- if numeq fails the generator is resumed
				- if numeq succeeds the unmark instruction is executed
				- unmark gets rid of the current expression frame but the C stack still contains a frame for the toby call and the interp() call
				- in the case of suspend, unmark will return A_Unmark_uw to interp()
				- so when interp() returns to a C function with an unwinding signal, all of the C stack frames will return in order until the ilevel is correct

		- Generative Control Structures
			- besides functions and operators, there are several generative control structures at the VM instruction level
			- Alternation
				- ex.
						expr2 | expr3

						VM instructions

							mark L1
							code for expr2 
							esusp
							goto L2

						L1:
							code for expr3
						L2:

				- mark creates an expression frame for alternation 
				- this frame preserves to failure ipc for L1 in case you need to compute expr3
				- if expr2 returns a result, esusp creates a generator frame, then copies the portion of the stack starting at the end of the last expression/generator marker and the alternation marker
				to the top of the stack
				- then it pushes a copy of the result of expr2
				- what this does is connect the surrounding expression with the result of expr2
				- next esusp sets the efp to point to the expression frame marker that comes before the alternation control structure
				- ex. 

						write (i := 1 | 2)

				- the top of the stack for this expression after esusp looks the same as if there were no alternation
				- but the generator frame marker pushed by esusp contains a pointer to the alternation marker L1
				- if a second result from expr2 is needed the generator frame left by esusp is removed which leaves the stack in the state it was in before the alternation

			- Repeated Alternation
				- repeated alternation |expr is the same as
					- expr | expr | expr |
				- the difference between repeated and general alternation is the special termination condition which causes the expression to repeat until it produces a result
				- without the termination conditon, expressions like generators that just produce values like upto() would never return upon failure
				- this results in the expression evaluation "black hole", or stuck in limbo with nowhere to go
				- the VM instructions for |expr are

					L1:
						mark0
						code for expr
						chfail L1
						esusp

				- mark0 creates an expression marker with a zero ipc failure pointer
				- if a zero failure ipc is encountered in efail, failure transfers to the enclosing expression
				- however if expr produces a resultthe chfail instruction is executed and changes teh failure ipc in the current expression marker to correspond to L1
				- this means when expr is resumed, if it does not produce another result, execution transfers to L1 in the icode which causes another alternation iteration

			- Limitation
				- in the limitation control structure, expr1 / expr2...
				- normal evalaution is reversed and expr2 is evaluated first 
				- the VM instructions are...

					code for expr2
					limit
					code for expr1
					lsusp

				- if expr2 succeeds, it's result is pushed to the stack
				- limit checks to see if the result is legal (int >= 0)
				- if the result is not legal, first it tries to convert it
				- if the limit value is zero limit fails, else limit creates an expression 
				  marker with a zero failure ipx and execution continues so expr1 is evaluated in its own expression frame
				- if expr1 returns a result, then lsusp is called which recrements the limit 
				  value and suspends like esusp and creates a generator frame

		- Iteration
			- theres a difference between while and every loops
			- every is the iteration control structure and while is a conventional loop
			- the VM instructions for while do...

			L1:
				mark0
				code for exp1
				pop
				mark L1
				code for expr2
				unmark
				goto L1
	
			- if expr1 fails then the expression fails and control goes to the surrounding 
			  expression because failure ipc is zero
			- if expr1 succeeds then expr2 is allocated an expression frame and begins 
			  executing
			- the loop repeats whether or not expr2 succeeds
			- if expr1 fails then then the loop breaks
			- the every do instructions are ...

					mark0
					code for expr1
					pop
					mark0 
					code for expr2
					unmark
					efail

			- if expr1 fails then the expression fails and control goes to surrounding 
			  expression, same as while do
			- if expr1 succeeds, then it's result is discarded by the pop instruction
			  because expr1 is not used in any proceeding computation
			- however expr1's expression frame is not discarded and expr2 is 
			  evaluated in it's own expression frame inside of expr1's frame
			- if expr2 produces a result, then failure is caused in the expr1 frame, and 
			  the expr2 frame is removed
			- if expr2 fails, then failure also goes to the expr1 frame 
			- the outcome is the same, either way which is a forced failure
			- if the expr1 frame contains a generator frame, that is if expr1 suspended, 
			  the generator is resumed 
	
Functions, Procedures, and Co-Expressions
	- expression rely on function and procedure invocation
	- There are multiple aspects of procedures that make the 
	  implementation complicated
	- fucntions and procedures are data values that can have assigned 
	  identifiers in
		Icon
	- this being said, the value of a procedure cannot be known until it 
	  is evaluated at runtime
	- functions and procedures can also be called with less or more arguments than 
	  expected
	- Co-Expressions need their own program stacks which further complicate things
	- ex.
			expr0(expr1, expr2, ..., exprn) has VM instructions...

			code for expr0
			code for expr1
			code for expr2
			...
			code for exprn
			invoke n

	- each time the code for an expression is evaluated the result is pushed to the 
	  stack, so the stack will have exprn's result at the top
	- the action taken by invoke depends on the result of expr0
	- if expr0 is an integer (or convertable to int), then the invokation expression corresponds to mutual evaluation
		- if its mutual evaluation, then the nth argument is copied on top of the result of expr0
		- sp is set to this location and invoke transfers control to the top of the interpretive loop
	- invoke fails if the integer is out of range
	- if expr0 is a function or procudure, then the corresponding function/procedure must be called with the arguments
	- each procedure and function have their own descriptor

	- Procedure Blocks
		- procedure blocks are constructed by the linker using info from the translator
		- these blocks are read in as a part of the icode file when an icon file is executed
		- procedure blocks contain ...
			- title word
			- size word
			- icode location of the first VM instruction for the procedure
			- number of arguments expected
			- number of local identifiers in the procedure
			- number of static identifiers in the procedure
			- the index of the static identifier array of the first static identifier on the procedure
			- a c string for the name of the file in which the procedure delcaratioin occurred
			- the rest of the block contains the following qualifiers ... 
				- the string name of the procedure 
				- the string names of the arguments
				- the string names of the local and static identifiers
			- the indices for the static indentifier array are indexed by 0
		
		- Function Blocks
			- function blocks are similar to procedure blocks, they have the same source language type distinction
			- function blocks are created using the marc FncDel that occurs ar the beginning of every C function that implements an Icon function









				


































