UNICON NOTES

QUESTIONS :
	pg 60 parallel evaluation ex at top
	how does map() work?

	childtask and parenttask examples don't seem to work properly
	seems to be a problem with while pull(L) and while put(L, read()) 
	on page 84

	Multi-Line Comments?

	the line of code...
	until L := trylock(L1 | L2)
	is a loop which tries to acquire a mutex
	how is this different/better than a spinlock (busy wait)

	extra files creates when compiling programs with classes





		

Goal-Directed Evaluation
	- each expression evaluates to success or failure
	
	instead of...
		while(i :=read()) ~= -1 do
			process(i)
	
	you can do...
		while(process(read))
		
	allows for certain cool expressions 
		if 3 < i < 7 then ...
		
Fallible Expressions
	- some expressions fail to produce a result, therefore failing
	- fallible expressions control the flow of execution
	- predicates are expressions whose purpose is to fail if a condition is not satisfied
		- ex. x[i] fails if i is out of index
		      x[i:j] fails if i or j is out of index
			  read() fails is End of File
	- assume any procedure is fallible and check if it failed
		- unless you know for sure that it is infallible or if failure doesnt matter
	- < are common numeric predicates
	- /x or \x test a single operand and test if is null or non-null
		- returns x
	- numeric comparison 
		<  <= > >= = ~=
	- lexical (alphabetic) comparison
		<< <<= >> >>= == ~==
	- reference comparison
		=== ~===

Generators
	- expressions that can generate more thaat one result are called generators
	- ex. find("lu", "honolulu") #produces all positions where the substring occurs
	- if a surrounding expression only needs 1 value from a generator, then the generator
	  will procduce the 1st value
	- ex. 3 < find("or", "horror")
		  find returns 2 first which fails
		  find returns 5 next which succeds
	- alternator operator |
		- expr1 | expr2
		- ex. x = (3 | 5) 
		      checks to see if x is 3 or 5
		- ex. (x | y) = (3 | 5)
			  checks tp see if x or y is 3 or 5
			  equivalent in C :
					(x == 3) || (x == 5) || (y == 3) || (y == 5)
	- to generator
		- ex. i to j produces all values between i and j
		- ex. t to j by k procduces all values between i and j incremented by know
	-  bounded expessions
		- expressions that never resume their generator subexpressions
		- ex. if statements, while statements
		- ex. expr1 ; expr2 evaluates exp1 tehn expr2 in order without backtracking
		
Iteration and Control Structures
	- The big difference b etween control structures and ordinary operators or 
	  procedures is that ordinary operators and procedures don't execute until their 
	  arguments have been evaluated and produced a result; they don't execute at all 
	  if an argument fails. In contrast, a control structure uses one of its arguments
	  to decide whether (or how many times) to evaluate its other arguments.
	- every control structure
		- like a for loop sort of
		- every expr1 do expr2
		- ex. every i := 1 to 10 do write(i)
		- generators are used for the first expression
		- better way to do the loop
			- every write(1 to 10)
		- a generator operand to a non-generator can become a generator with the every
		  control structure
		- every expressions are more flexible than for loops 
			- ex. every func(1 | 4 | 9 | 16 | 25 | 36)
			      is the same as...
				  every func((1 to 6)^2)
		- other control structures
			- until expr1 do expr2
				- works like a while loop except it executes expr2 as long as expr1 fails
			- repeat expr
				- infinite loop 
			- case expr of {
				branch1: expr1
				branch2: expr2
				...
				default: expr_i
			
			  }
				- branch expressions can be generators, expr evaluates each generated value
		- exit(), stop(), runerr() functions all terminate the program
		- break expr 
			- breaks out of a loop
			- expr is evaluated outside of the loop and treated as the value produced by executing loop
		- next
			- like continue
			
Procedures
	- like a function
		- ex. procedure poly(x,a,b,c)
			       return a * x^2 + b * x + called
			  end
	- Parameters
		- passed by value except for structured data types which are passed by reference
			- parameters passed by value get a copy of the values
			- any changes in the copy will not be reflected in the original
		- a procedure with too many parameters will discard the extras
			- valuable for prototyping 
		- a procedure with too few parameters will assign &null to missing ones
		- operators / and \
			- /x succeeds and return x if the value is &null
				used to assign default values to variables
				- ex.
					procedure succ(x, i)
						/i := 1
						return x + i
					end
					
					if called as succ(10, the missing parameter is assigned the null value 
					then the / tests if i is null which succeeds; therefore the value 1 is assigned
			- \ checks if hte argument is non null
				- ex. 
					write("The value of x is" \x)
					
					if x is null \x will fail and write will fail
					
		- defaulting and type conversion exists for much of the built in functions
			- ex. 
				procedure succ(x:integer, i:integer:1)
				
				converts both x and i to integers and enforces a default 1 for i if it is missing
				in the calling expression
	- Variables and Scope
		- the scope of parameters is limited to the body of the procedure
		- parameters and procedures are special forms of the two types of variables
		- Global and Local variables
		- variables are local by default
		- define a global variable outside a procedure
			- ex. global MyGlobal
		- when you define a procedure, it creates a global variable intitialized with the procedure 
		  value containing the procedure's intructions
		- inital clause
			- initialize static variables in ways that arent handled by initializers
			- ex. 
				procedure fib()
					static x,y
					local z
					initial {
						x := 0
						y := 1
						return 1
					}
					
					z := x + y
					x := y
					y := z
				end
			
				this returns the next number in the fibonacci sequence each time it is called
				it uses static variables to remember the results of the previous call
	- Writing your own Generators
		- you can use the "suspend" keyword instead of "return" in a procedure to create a generator
		- suspend saves the point of execution within the procedure
		- ex. procedure to generate squares
			procedure squares()
				odds := 1
				sum := 0
				repeat {
					suspend sum
					sum +:= odds
					odds +:= 2
				}
			end
		
			now we can use it in an every structure
			
			every munge(squares())
			
			this is an infinite loop since every will always resume squares() whether
			or not munge() succeeds or fails
		- the fail expression makes the procedure fail
			- control goes to the calling procedure returning no value
			- ex. 
				procedure nonblanks(s) 
					every c := !s do {
						if c == "#" then fail
						if c ~== " " then suspend c
					}
				end
				
				produces all the nonblank characters in a string
	- Recursion
		- ex. towers of hanoi
			procedure hanoi(n, needle1:1, needle2:2)
			local other
				if n = 1 then write("Move disk from ", needle1, " to ", needle2)
				else{
					other := 6 - needle1 - needle2 #3
					hanoi(n - 1, needle1, other)
					write("Move disk from ", needle1, " to " needle2)
					hanoi(n - 1, other, needle2)
				}
			end
		
Structures
	- Tables(hashtable, dictionary), Lists, Records, Sets
	- copy() makes a shallow copy 
	- deepcopy() makes a deep copy
	- Tables
		- Unordered, collection of values that are accessed uing associated keys
		- most versatile structure
			- the others re special cases of tables optimized for common operations
		- ex. 
			T := table()
			T["hello"] := "goodbye" 
			# defines a key-value pair, key -> hello, value -> goodbye
			
		- table() takes an optional arg which defines the default value when a lookup fails
			- the default of the default is &null
		- insert(T, k1, v1, k2, v2, ...) adds new key-val pairs
		- delete(T, k1, k2, k3, ...) deletes key-val pairs based on key
		- unary operation * produces the size of the argument
			- *T gives the number of pairs
		- !T generates the values stored not the keys
		- unary ? is the random operator	
			- ?T gives a random value in the table not the key
		- member(T,k) succeeds if k is a key in T and fails otherwise
		- key(T) generates the keys
		- ex. Wordcounts, getword() generates a word
			wordcount := table(0)
			every word := getword() do wordcount[word] +:= 1
			evert word := key(wordcount) do write(word," ", wordcount[word])
		- the keys of a table are a set
		- using the ! operator generates the values in a psuedorandom order
		- tables support set operations
			- union T1++T2
			- intersection T1**T2
			- difference T1--T2
			- for union and intersection when duplicate keys occur the left operands values are used
	- Lists 
		- dynamically sized, ordered collections of values
		- indexed starting with 1
		- can insert anywhere in the list
		- take the place of arrays, queues, and stacks
		- created with list()
			- optional arguments are size and initial value
			- default is 0 and &null
		- or created with...
			- L := ["linux, 2.0, "unix"]
		- or with list comprehension
			- L := [: expr :]
		- insert(L, i, x) inserts x at index i in list Lists
		- delete(L,i) deletes and element at index i
		- no type restriction on list elements
		- multidimensional lists
			- L[2][3] is the same as L[2, 3]
		- common operators
			- *L -> size
			- !L -> generate elements in sequence
			- ?L -> generate elements randomly
		- member(L, k) succeeds if 0 < integer(k) <- *L
		- slice lists with L[i:j]
			- L[i+:j] -> L[i:i+j]
		- concatenation operator
			- L1 ||| L2
	- Records
		- fixed size, ordered collection whose elements are accessed using user-defined fields
		- A record is declared as a glbal name that introduces a new type witha corresponding 
		  constructor procedure
		- field names are a comma-seperated list of identifiers enclosed in parentheses
		- ex. 
			record complex(re, im)
		- instances are created by using a contructor procedure with the name of the record type
		- the fields of an instance are accessed by using dot notation or index
		- you can use records as special tables, or lists with  constant size and fixed keys
		- member(R,s) test whether s is a field in R
		- key(R) generates the field names
		- functions like insert() and push() arent supported
		- ex. 
			a := complex(0,0)
			b := complex(1, -1)
			if a.re = b.re then write("not likely")
			if a["re"] = a[2] then write("a.re and a.im are equal")
		- records can be seen as optimized special objects with no methods
	- Sets
		- unordered collection of values with the uniqueness property
		- set(x...) creates a set from its arguments
		- set("rock" lobster", 'B', 52) -> set(["rock" lobster", 'B', 52])
		- set(L) not allowed, instead do set([L])
		- can do set comprehension by wrapping the comprehension in a list
			- set([: 2 to 20 by 2:])
		- supports member(), insert(), delete()
		- set operations
			- S1++S2 union
			- S1**S2 intersection
			- S1--S2 difference
		- because a set can contain any value, it can contain a reference to itself
			- this is a difference between unicon sets and mathematical sets
			- unicon sets are also finite
		- uniq UNIX utility filters duplicate lines to stdin and writes to stdout
		- ex. procedure main()
				S := set()
				while line := read() do
					if not member(S, line) then {
						insert(S,line)
						write(line)
					}
			  end 
		- sets have no default value and do not support indexing
	- Using structures
		- structures can contain structures
			- allows for complex organization of date
		- example code in VM
	*** link keyword allows you to import modules ***
	
String Processing
	*** || operator concatenates strings ***
	*** == operator compares strings ***
	- csets are denoted with single quotes ''
		- like sets, no duplicates
		- csets and strings are convertible
	- tricks
		- see if a string is all vowels
			if cset(s) == 'aeiou' then ...
		- find all distinct characters in a string	
			n := *cset(s)
		- ! operator gives the members of a cset in sorted order
	- character escapes
		- \n, \t
		- \x41, hex
		- control characters represeted with ^
			CTRL-C -> \^c
		- escape code table on page 43 of UNICON book
	- string scanning
		- scanning environment consists of 
			- string &subject and string &positions
		- enviroment created with 
			- s ? expr
		- binary ? operator sets subject on the left and inits position to 1
		  then it executes the expression on the right
		- expression usually uses various matching functions 
			- a matching function changes the position and returns a substring
			  between the old and new positions
				- ex. move(j) moves the position j places to the right
				- ex. 
					text ? {
						while move(1) do
							write(move(1))
					}
					# this writes every other character of text
				- ex. tab(i) sets &pos to its argument and returns the substring 
				  it passed over, tab(0) returns current position to end of string
				- ex. find() looks for substrings
				*** Note tab() and move() reset the &pos upon failure ***
			- matching functions have 3 optional parameters
				- a string to examine, default -> &subject
				- 2 integers, where in the sring the processing will be performed,
				  default -> 1, 0
			- unary equals -> =s
				- the same as tab(match(s))
				- means check if the current position is the same as s, and if it is
				  move past it.
			- refer to unicon book pg 44 for more string scanning functions

Advanced Language Features
	- alternation operator (|) resembles short circuit OR
		- generates left operand and only evaluates the right operand if the left fails
	- conjunction operator (&) resembles short circuit AND
		- evaluates left and if that succeeds, evaluates right and the result of the 
		  expression if it succeeds is the result of the right operand
		- alternate syntax expr1 & expr2 -> (expr1, expr2)
			- any number of expressions can be present
	- negation
		- not keyword, not expr
		- if expr has no result, then not expr succeeds and produces a null value
		- if expr produces a value, then not expr fails 
	- list structures and parameter lists
		- prodecure myfunc(x,y,z[])
			- this makes any parameters supplied after the third is a list
			- ex. myfunc(3,4,5,6,7)
					-> x = 3
					   y = 4
					   z = [5,6,7]
		- supply a list as a parameter	
			- ex. write ! L
					-> all elements of L are given to write
	- Co-expressions
		- independent, encapuslted thread-like-context where the results of 
		  an expression can be picked off one at a time
		- you might need to seperate the evaluation of an expression from it's location
		  in the code
			- normal way to do this is with a procedure
			- what if you want to use the results from a single instance of a generator
				- ex. 
					labelname := create("_L" || seq())
					varname := create ("_V" || seq())
			- create(expr) allocates and initializes an evaulation context and memory needed 
			  to evaulate expr, but does not evaluate it
			- the co-expression value may be used outside the call where it is created, so 
			  the evaluation context includes a copy of the local varibales and parameters needed
			  in the expression
			- when a co-expression is activated, it produces the next value
				- activated with @ operator.
				- each call of @labelname produces "_L1", then "_L2", etc
			- after a co-expression produces all the results any further @ calls will fail
			- the ^ operator produces a the same co-expression, but rewound to the beginning
				- ex. c :- ^c
	- User-Defined Control Structures
		- co-expressions can be used to implement new control structures when procedures
		  that take co-expression parameters are used to control the order and number of
		  times that they are activated
		- can be called like
			proc([create e1, create e2, ... create en])
			or
			proc{e1, e2, ..., en}
	- Coroutines
		- procedures have an asymmetric relationship
			- when a procedure is called the execution starts from the top
			- when a coroutine is called, execution starts from the point execution was suspended
		- Process called resumption
	- Permutations
		- map() can be used to permute strings
			- ex. write(map("01234", "43210", "abcde")
					-> returns "edcbe"
			- ex. map("Mm/Dd/XxYy", "Dd/Mm/XxYy", date)
					-> swaps the months and days in a date string
			*** Note map() removes punctuation characters from fixed format strings
	- Simulation
		- Galton box example
		- FillArc(x,y,width,height) : fills an ellipse defined by a bounding rectangle
		- WAttrub("attr=value") : generic getter/setter for window attributes
			- fg = foreground color
			- drawop = raster drawing operation
		- Window("attr-value", ...) opens a window with characteristics defined by the 
		  string attr values
		- WDelay(t) : waits until t milliseconds have passed
		- WDone() : waits fro user to dismiss the output window by pressing "q" and then
		  terminates the program and closes the window
<<<<<<< HEAD

System Interface
	- Files and Directories
		- read("myfile", "rw") and write(filename, "test to be written")
		- default mode for read is "r"
		- another way to read lines is with unary !
			- ex. every put(L, !file)
					places lines of file into list L
		- reads(f, i) reads up to i characters
		- writes(f, s, ...) writes strings to a file
		- close(f) closes a file
		- std files &input, &output, &errout
		- chdir() with no arguments returns cwd
		- chdir(dirname) sets cwd to dirname
		- open(dirname) opens a directory and reads its contents
			- directories cannot be opened for writing
			- every read() from a directory returns the name of a file in 
			- every write(!open(".")) writes the name of the files in the current 
			  directory
		- mkdir(s) creates a directory
			- optional second argument specifies permissions
		- files/directories can be renamed with rename(s1, s2)
		- remove(s) will delete a file or directory
	- Obtaining File Metadata
		- owner, size, access rights, etc
		- stat() returns this info in the form of a record
	- Controlling File Ownership and Access
		- chown(fname, user, group) changes the ownership of a file
		- chmod(fname, mode) changes the files access rights
			- mode is either a nine letter "rwxrwxrwx" string or 3 digit octal code
		- these functions only succeed for certain users
		- umask is a variable that tells the system what the access rights for newly 
		  created files/directories will be
		  	- umask("rwxr-xr-x")
		  	- overwrite umask with mkdir(dirname, mode)
	- File Locks
		- files can be locked while updating info so that no other processes can read 
		  or write to it
		- flock(filename, "x") creates a lock and subsequent calls by other processes 
		  will be blocked until the lock is released
			- "x" argument indicates an exclusive lock, which should be used when 
			  writing
			  	- an exclusive lock means that no other processes can be locked
			- "s" argument creates a shared lock which should be used when reading
				- a shared lock lets other processes continue reading while locked
	- Process Control
		- similar to C POSIX interface
		- include file posix.icn for constants used by certain functions
			- $include "posix.icn"
		- signals
			- an asynchronous message sent to a process either by the system or by 
			  another process
			- a process can handle a signal in two ways
				- let the system handle it in the default way (often results in 
				  process termination)
				- define a function to handle the signal (signal handler)
			- trap(s, p) traps or ignores signals
				- s is the string name of the signal
					- see appendix E
				- p is the procedure to call when signal is received
		- Launching programs
			- best way to start a program is with open() with mode "p" (pipe)
			- when you use mode "p" the filename argument is instead a command string
			- piped commands ("p", "pr") let your program read the commands output 
			- piped commands ("pw") let your program write the commands output
			- system(x, f1, f2, f3, mode) is another way to run commands
				- "x" is the command string/list where x[1] is the command and the
				  other list elements are the arguments
			- the calling program waits for system() to be returned before continuing
				- the exception is when the command ends with &, or the mode arg is 
				  1, or "nowait"
			- system() takes 3 optional file arguments
				- redirected stdin, stdout, stderr files for the launched program
			- system() accepts redirection operators in the command string
			- pipe() function returns a pair of open files in a list, with the 
			  property that anything written to the second will be written to the 
			  first
				- ex. connect a pipe between 2 processes
					L := pipe | stop("Couldn't get pipe", &errortext)
					system("prog1 &",, L[2])
					system("prog2 &", L[1])
					close(L[1])
					close(L[2])
		- Process Information
			- getpid() returns pid 
			- getuid() returns user id
			- wait() returns a string of the form "pid:status:arg:core" to the parent
			  when the child process changes from running to exited or terminated
				- ":core" will be present if the system created a core file for the 
				  process
				- status can be "exited", "terminated", or "stopped"
				- arg is either the exit status, or the signal name
				- normally wait() is used in a signal handler for the SIGCHLD signal, 
				  which is sent to the parent when the child changes state
				- arguments to wait() are the pid of the process to wait for and any  
				  options
					- default is to wait for all children
			- select() system call
				- sometimes programs need to read data from multiple sources, like 
				  keyboard and a socket
				- the problem with read() is that if the input does not exist then 
				  the program blocks and the other streams cannot be read
				- select(x1, x2, ..., i) tells the system what files you want to read 
				  from
					- when any input from the args becomes available it notifies the 
					  program
					- takes files or lists of files as args
					- returns a list of files on which input is waiting
					- if you give it an integer i, it waits for i milliseconds and if
					  no input is available, it returns an empty list
					- if there is no integer timeout arg, the program waits  
					  indefinitely
					- Note: select only requires that 1 char be available in order to 
					  return it
				- a primary use for select() is with network programming
	- Networking
		- TCP
			- need to know name of machine (IP address) and the port number
			- call to open() with mode "n" requests a network connection
				- arg 1 is the network address (host:port pair and a filename for 
				  UNIX domain sockets)
				- If the address has no hostname (starts with ":") the socket is 
				  opened on the same machine
				- open(..., "n") opens a file (socket) that can be used in select()
				- can also be used to open a connection to a tcp server
			- getserv() returns a record that includes fields for name, alias, and 
			  port number
				- the input string is the name of a common protocol
				- getserv() will translate the string into the port number so you 
				  dont have to remember
			- to write a server, we just need to add "a" to the open mode after "n" 

Determining IP Numbers
	- given network connection f, image(f) should show the clients IP 
	  and port that is connected (called peername)
	- some programs need to know thier own IP numbers, but there may be 
	  multiple for 1 machine for each network device
		- sbin/ifconfig outputs a list of local IPs
		- gethost(n) returns a string wuth the IP num and port used by 
		  the local machine for a connection n
	- the number returned from ifconfig or gethost is not what the world 
	  sees when you connect to the internet
		- this is because most devices connect through some type of 
          network address translation 
        - in order to see what the world sees you have to connect to 
          another machine and ask them what they see
Non-blocking Network opens
	- a server does'nt have to block when waiting for a connection
	- open(":port", "nl") opens a listener
		- the file returned os not for reading or writing 
		- if the listener gets a connection request, select() converts 
		  it to a normal network connection

UDP
	- messages are not guaranteed to go through and may not arrive in 
	  the order they were sent in
	- cheaper and faster to send then tcp
	- can be sent using either open()/writes() or send()
		- servers use open() then read() and write() since its sends and 
		  receives on the same socker
		- clients that only send 1 or 2 udps use send()/receive()
	- open() should be used with "u" mode to indicate udp
	- receive() constructs a record with the address and the message
	- ex. 
		f :=open(":0125", "nua") #open a udp server
		while r:= receive(f) do{
		#process message in r.msg
		....

		send(r.addr, reply)
		}

Unicon Messaging Facilities
	- open() with mode "m" establishes a messaging connection
		- the filename arg to open() for a messaging connection is a URI
		  (Uniform Resource Indicator)
		- the URI specifies the protocol, host machine and thing to read
		  write
		- ex. 
			open("mailto:unicon-group", "m", "Reply To: jeffrey@cs.uidaho.edu")
			#this establishes an smtp connection and sends a header defined by smtp to supply a reply-to field 

		- implemented protocols include HTTP, HTTPS, Finger, SMTP, POP

HTTP/HTTPS
	- used to read or write to web servers
	- the contents of the message are ususally HTML text
	- programs that connect using http can check the status code of a 
	  failed request to determine the cause
	- status codes and other http metadata are retrieved by subscripting 
	  the connection with the header
		- ex. f1["Status-Code"] would return the code
			  f1["Lacation"] would return the new location of the file
	- it is possible to retreive this metadata without getting the 
	  file itself using the "ms" mode instead of "m"

Tasks
	- tasks are executing programs in the unicon VM
	- the root task is created when the interpreter starts and other
	  tasks are spawned dynamically as needed
	- unicon programs can use the tasking facilities to launch, load,
	  and execute other programs all wihtin a single instance of the
	  unicon interpreter
	- unicon tasking can be used to load and execute other programs
	  withing the same interpreter space however they do not provide 
	  concurrent programming for those programs or provide special support for multiprocessor hardware
	- co-expressions provide the tasking execution model
		- c-expression activation serves as the communication mechanism
	- programs that use the tasking interface can communicate with each 
	  other without having to use system IPC mechanisms like pipes, or 
	  external files
		- in this way tasking provides a communication interface for 
		  unicon programs that need to have extensive access to each other wihtout relying on system IPC
	- there are several built in functions and keywords
	- no new types, declarations or control structures
	- the functions are extensions of previously existing functions
	- new definitions that pertain to regions of memory referenced by 
	  executing programs
		- namespace : a mapping from a set of program source code 
		  identifiers to a set of assiciated memory locations.
			- Icon programs have a global namespace shared across the 
			  program
			- Each procedure has it's own static namespace shared by all 
			  calls to that procedure that consists of the memory locations shared by those calls, and local namespaces private to each of the calls
	- when a co-expression is created, a local namespaces is 
	  allocated for that invocation of the procedure and the local variables are placed into the namespace for use by 
	  subsequent calls
	- An icon program has a program state that is made up of  
        the  memory assiciated with the global and local namespaces keywords, and dynamic memory regions
      - also co-expressions have a co-expression state that has 
        an evaluation stack that contains the memory used to implemetn one or more of local namespaces 
      - the main point of all this is that co-expressions SHARE 
        access to the program state which the can use to communicate 
  - task starts as a main co-expression with 0 child co-expressions
  - a main coexpression and the children all share the program state, 
    which contains global/static namespaces, keywords, and dynamic memory regions
  - at the source code level tasks are loaded reference and activated
    solely in terms of one of their member co-expressions 
    	- this means that tasks are implicit and not excplicitly defined
  - task creation
  	- tasks can be created using load()
  	- ex. load(s, L, f1, f2, f3, i1, i2, i3)
  	- this ex. loads an icode file specified by the file name s, 
  	  creates a task for it and returns a co-expression corresponding to the invocation of the procedure main(L)
  		- default L is an empty list
  		- unlike command line invocation, using load() allows you 
  		  to use any data type as arguments to the task, including prodecures, lists, tables, etc
  		- a task loaded wiht load() is considered a child task
  	- f1, f2, f3 are files corresponding to &input, &output, &error
  		- default for these files are the $input, &output, &error  
  		  of the calling task
  	- i1, i2, i3 are integer arguments that specifc the memory 
  	  region sizes for the child tasks block, string and stack memory
  		- i1, i2 default is 65000, and i3 is 20000
  		- defaults can be changed by the environment vars BLKSIZE, 
  		  STRSIZE, MSTKSIZE
  - Running other tasks
  	- a task created by load() is no different than any other
  	  co-expression, @ will start executingthe childs main procedure
  	- the child will run until it completes or invokes &source, or 
  	  suspends
  		- *** remember &source will activate the parent 
  		  co-expression ***
  - Data Access
  	- every task has a seperate program state but they all share 
  	  the same memory space
  	- this allows them to share data
  	- values can be shared between tasks through main()'s argument 
  	  list
  		- this is possible if you use co-expression activation, the
  		  argument list , or by using event monitoring used in chapter 10
 	- Access Through Task Argument Lists
 		- a program can take its argument to be an icon rpgram to load and 
 		  execute as a child
 		- this is acheived in a similar way to the pipe feature in bash
 		- this technique can be used to pass entire data structures and 
 		  icon types from program to program without having to encode them 
	- Inter-task Access Functions
		- functions that provide inter-task access
			- variable() : takes a coexpression value as an optional second
			  argment, which denotes the task from which to fetch the variable from
				- useful for retriving variables from another task for either 
				  reassignment or reading
			- cofail(C) transmit failure to C
			- fieldnames(r) generate fieldnames of record r
			- globalnames(C) generate C's global variables
			- keywords(s,C) prodces keword s in C
			- ..., etc, table on page 85
		- particularly useful for program execution monitoring 
	- Shared icode libraries
		- programs written for the multi-tasking envrionment are more
		  efficient, modular, and make better use of space
		- code sharing can be implemented using data sharing
		- programs running on a single instance of the interpreter can 
		  share code easily unless the code makes modifications to global variables in the calling tasks program state
			- in this case you must be careful to explicitly refernce the 
			  calling tasks state
	- Loading shared code 
		- lets say a series of applications need to use the Icon program 
		  library (IPL) functions
		- the IPL library need only to be loaded once, after they can be 
		  shared among the applications
		- in order to share code from a loaded task there are 2 requirements
			- the shared code must be loaded
			- the client tasks must be able to dynamically link shared 
			  routines into their generated code
		- in order to introduce a shared Icon procedure into the namespace, 
		  a global variable must be declared that has the same name as the namespace

Databases
	- different kinds of databases are appropriate depending on how much 
	  information needs to be stored as well as what kinds of access needs to be supported
	- Memory-based Databases
		- if a databased can fit in memory, it allows you to avoid the disk
		  and make the information access more efficient
		- xcodes procedures convert structuresto strings and store them to files
	- DMB Databases
		- DMB : database manager, UNIX databases
		- the DMB functions maintain key value associations on the disk
			- similar to table data type
		- superset libraries of DMB are NDMB and GDMB <- used by unicon
		- accessed with open() with "d" mode for rw or "dr" for read only
		- manipulated using table operations
		- closed with close()
		- best for databases with simple organization
		- a limitation of DBM is that they are string bases
			- ex. tables can have a key 1 and a key "1" but this is
			  impossoible with DBM
			- cannot use structures like records or lists as elements
				- although you can use xencode() and xdecode() if you really  
				  need to
	- SQL Databases
		- better for complex databases not organized around single keys
		- Structured Queury Language
		- can contain multiple tables accessed by walking through a set of
		  results to some queury
		- a database is a collection of tables, where each table is a
		  collection or rows, and rows contain informtaion of different types in a set called columns 
		- 2 ways to do stuff in SQL in unicon
			- using unicon operations
			- using SQL statements
		- SQL statements
			- CREATE TABLE
				- create table addresses(name varchar(40), address varchar(40), 
				  phone varchar(15))
				- name is the primary key in the table addresses
			- SELECT
				- determines the data set being operated on
			- INSERT
				- adds new rows to a table
				- ex.
					insert into addresses(name, address, phone) values('Nick K', '1 Evil Empire', '(123)456-7890')
					insert into addresses(name, address, phone) values('Vic T', '23 Frozen Glade', '(900)888-8888')
			- UPDATE/DELETE	
				- can modify or delete sets of rows that match a certain 
				  criteria 
				- ex. 
					update addresses set address = '666 RTH Issaquah' where 
				  name = 'Nick K'
				  delete from addresses where name = 'Vic T'
			- for simple database tasks you can use the unicon builtin 
			  facilities, but for complex operations the best solution is to formulate your own SQL commands
		- Database architectures and ODBC

Threads
	- threads are an extension of the co-expresiion class and the system 
	  interface
	- threads in unicon are like asynchronous co-expressions
	- each thread has it's own program coutner stack and cput registers
	- but each thread in a program will share the same memory, open 
	  files, etc.
	- each thread has an entry point, ususally a procedure, but it can be 
	  any expression
	- threads never return they just terminate, while the others continue
		- exception is the main thread, the whole program ends when the 
		  main thread terminates
	- unicon threads can be created in 2 ways
		- using the thread reserved word
		- using spawn()
		- difference between these is the separation between creating a  
		  thread and running it
		- thread reserved word creates a thread and runs it while spawn() 
		  takes an already existing co-expression and creates a thread for it 
	- threads and co-expressions can be used outside of the scope   
	  where they were created
  	- copies of local variables in different threads can be though of
  	  as parameters passed to a procedure
  		- this is true of local variables and immutable types
  		- global variables and mutable types can be shared among threads 
  		  such as in lists
  - passing data to threads as arguments is easy
   	- you just create a thread from a procedure and pass the 
   	  arguments as paramters to the procedure 
  - thread safe code 
  	- each thread's data needs to be completely independent
      from other threads 
  	- avoid or rewrite any procedures or libraries that use 
  	  global or static variables
  	- use s synchronization mechanism if necessary
  - thread synchronization
  	- spinlocks (wait() or global variable flag)
  		- occupies a CPU core to keep spinning 
  	- mutexlocks
  		- a mutex object is created with mutex()
  		- the returned object can be locked and unlocked using 
  		  lock() and unlock()
  		- the more mutex locks you have, the slower the program
  		  will run, especially if the critical section is long
  		- special syntax
  			- critical mtx: expr

  			  is equivalent to ...

  			  lock(mtx)
  			  expr
  			  unlock(mtx)
  			- if there is a return in the expr, you must unlock the 
  			  lock manually before you return the expr
  		- trylock() is an laternative non-blocking function for 
  		  locking
  		  - if the thread cannot acquire the mutex immediately the 
  		    function fails
  		 	- most often used inside an if statement
  		- initial clauses are thread safe
  			- can use them to create a new mutex object
  		- in unicon thread-unsafe data structures can be protected 
  		  by turning on it's mutex attribute
  			- the data structure will lock/unlock implicitly
  			- initialize a thread safe structure with ...
  			  Structure := mutex(<init structure>)
  			- Use critical <structure>: expr, for non-atmoic 
  			  operations
  		- you can do thread safe concurrent assignment to a global
  		  variable only if the type of the global variable never changes, applies for shorts/longs as well
  	- Condition Variables
  		- condition variables offer thread blocking/unblocking that
  		  is not related to data sharing like with mutexes
  		- instead condition variables can wait for an event to
  		  happen before blocking/unblocking
  		- condvar() returns a condition variable object that can be 
  		  used with wait() and signal()
  		- wait(cv) blocks the current thread on the condition 
  		  varaible cv
  		- the thread blocks until anther thread uses signal(cv)
  		  to wake it up
  		- the conditional variable must always be associated with a 
  		  mutex
  			- this means that the wait() function must always be  
  			  protected by a mutex
  		- unicon has built in mutexes for conditional variables
  			- conditional variables can be used with
  			  lock()/unlock()/critical clause
  		- the condition or test that is the cause of the wait() on
  		  a conditional variable must also be protected with a mutex
  			- ex. lock(cv)
  							if x = 0 then wait(cv)
  						unlock(cv)

  						or...

  						critical cv: if x = 0 then wait(cv)

  						or the best way...

  						critical cv: while x = 0 then wait(cv)
  	- Thread Communication 
  		- co-expressions traditionally communicate using the @  
  		  operator
  			- x@C2 allows a co-expression C1 to communicate with
  			  another co-expression C2 passing a value x
  		- threads take this idea to another level 
  			- 4 new operators
  				- @>, @>>, @<, @<<
  				- send, blocking send, receive, blocking receive
  			- each thread maintains 2 message queues called inbox and 
  			  outbox
  			- Attrib() can be used to access or change the queue
  			  attributes
  				- Attrib(handle,attribcode, value, attribcode, value,
  				  ...)
  				- integer codes used by this fucntion are cotnained in 
  				  threadh.icn (import threads)
  				- when values are ommited Attrib() returns attribute
  				  values
  			- to synchronize message sending/receiving the blocking 
  			  send and receive operators are used
  				- instead of failing when they fail, these operators
						wait until the operation succeeds 
					- useful when the amount of messages sent may exceed 
					  the size of the message queue
		- Private Communication channels
			- inbox & outbox queues are visible to all threads at all 
			  times
			- sometimes 2 threads need to communicate without worrying 
			  about other messages sending or receiveing messages from their queues
			- channel() function opens a channel between 2 threads
				- need to use import threads
				- returns a list representing a bidirectional channel
				- takes one parameter, the thread that it wants to 
				  communicate with
				- uses the 4 communication operators
		- Thread Pool
			- included in the threads package
			- 4 procedures
				- MakePool(n) -> create a pool of n worker threads
					- default n is 2 + the number of processors
				- Dispatch(proc, params) -> Queue a task to be executed 
				  by a thread from the pool
						- if a thread is available the procedure will be
						  called immediately, otherwise it will be called when there is a thread available
				- isIdle() -> Succeeds if no workers are active and there 
				  are no tasks in the queue
				- ClosePool() Shuts down the pool after the remaining tasks have finished

Execution Monitoring
	- execution monitoring is when the user can execute a program
	  under the observation of one or more monitoring systems
	- terminology
		- dynamic loading : the ability to load multiple programs
		  into a shares execution environment  supports monitor access to target program data
		- synchronous execution : the monitor and target execute
		  independently, but not concurrently. this allows the monitor to control the target program execution using a simple programming model. co-expressions are used to supprot the monitor-target relationship
		- high level instrumentation : info about program execution 
		  is available in the langauge runtime system
		- events : an event is the smallest unit of execution 
		  behavior that is observable by a monitor
		- event codes and values : from the monitor's perspective an
		  event is made of 2 components, and event code and an event value. the code is genrally a 1 character string describing the event 

Object Oriented Programming
	- encapsulation : the isolation of some data representation and
	  the code that manipulates it
		- all of the source code that could affect the data structure
		  is present with the data's definition
		- methods are the public interface between the code in the 
		  object and outside the object
	- inheritance : code is shared by related data structures 
	  through a concept called inheritance
	  - when writing code for a data structure that is similar to
	    an already existing data structure, all you need to do is specify the differences between the two
	  - inheritance is useful when a data structure may
	    need an extension with new variables or operations but the old and new structures are both needed by the application
	  - the collection of all the inheritance relations defines a
	    directed, but not necessarily acyclic graph
	- polymorphism : when executing code containing objects, the 
	  code may invoke any encapsulated facilities within that object regardless whether that facility belongs to the original class or the inheriting class
		- this is possible through encapsulation of all object code
		  within the declared object
		- algorithms called generic algorithms use polymorphism to 
		  act upon different object types
		- polymorphic code can execute an operation on any object 
		  that implements the usage of the operation in the class 
	- Objects in Program design
		- objects can be used to model the program domain
		- the objects and the relationships between them give
		  fundamental information that organizes the rest of the program design
		- UML
	- Declaring classes
		- syntax...
			class foo(attr1, attr2, attr3, ...)
				# procedures (methods to access class foo objects)

				# code to init class foo objects (constructor)
			end
		- methods are procedures that manipulate class objects
			- define an interface between the object and the executing 
			  code
			- syntax...
				method bar(param1, param2, param3, ...)
					# code that may access fields of class foo object
				end
			- all methods have access to the implicit variable self (a 
			  record holding the attributes)
	- Object Instances and Initially Sections
		- object instances are created using a constructor procedure 
		  with the same name as the class
		- fields of an object do not necesarily have to be 
		  initialized with a parameter passed to the constructor
			- therefore class decalration includes an initially section
			- ex.
				class taque(L, T)
					# methods

					initially 
						L := []
						T := table()
				end
			- each class's default constructor procedure works like a 
			  records, the initially section acts like a traditional constructor in java
			- you can pass arguments to the initially constructor like 
			  initially()
			- you can use initially with no parameters to utilize the 
			  default constructor procedure while also implicitly initializing other fields not initialized by the 
			  constructor
				- this can be awkward sometimes so there exists an 
				  alternative
			- when an initially section includes a parameter list, it
			  frees the constructor from assigning fields in the order that they appear
	- Object Invocation
		- object invokation is a combination of a procedure call and 
		  a record access
		  - ex. object.methodname(arguments)
		- methods can also be called using proceudre calls
			- x.method(arguments) --> Class_method(x, arguments)
		- you should not access an objects fields direcly using the .
		  operator, it is better practice to use getters and setters
		- the usage of self is implicit to methods so you rarely have 
		  to explicitly use it

Inheritance and Associations
	- some classes are very similar to others
	- inheritance is a way to reduce code repetition
	- a class defined in terms of another class is a subclass
	- a class from which a subclass is defined is called a
	  superclass
	- an object of a subclass can be manipulated in the same way as
	  if it were an object of the superclass
		- similar classes can now share code that manipulates thier 
		  fields
	- syntax of a subclass ...
			class classname superclasses (attributes)
				methods
				initially section
			end
		- the superclasses part is a list of classnames seperated by 
		  colons
	- Unicon has a unique OOP perspective when it comes to 	
	  inheritance
	 	- in unicon, inheritance is seen as the additon of superclass
	 	  elemets to the sublclass
	 	- in traditional OOP, subclasses are often seen as an 
	 	  augmented instance of the superclass
		- this difference allows unicon to do cool stuff like define
		  classes as subclasses of each other
	- invoking superclass operations
		- somtimes subclasses can have a method of the same name as a 
		  method defined in the superclass (called overriding)
		- the default behavior is to invoke the subclass method
		- in order to invoke the superclass method you need to say...
			object@superclass.method(paramters)
		- you can do this with initially sections too
	- superclass cycles and equivalence
		- many times there are several ways to represent an abstract 
		  type
		- ex. cartesian vs radial coordinates
		- we can define two classes that are superclasses of each 
		  other
		- the superclass decalrations make the two types equivalent
		  names for the same tpye of object
		- after inheritance the objects from either class will have 
		  fields x,y,d,r and they will both support the same 
		  operations
		- often times the different paramters and thier ordering will 
		  distinguish the difference and reflect different POVs
		- although each object will support the same operations the
      methods invoked may be different depending on which constructor was used
    - if a class inherits methods from an equivalent class, it is
      responsible for initializing the fields which that methods uses in it's constructor
  - Associations
  	- association : a relationship that occurs between objects at 
  	  runtime
  	- an instance of an association is called a link
	  - Aggregation
	  	- an object made up of a composition of multiple other objects
	  	- ex. a dictionary is made of many dictionaryentry objects
	 	- User-defined associations
	 		- custom associations defined by the application designer
	 	- associations are not completely specified until the details
	 	  are determined during program design
	 	- Multiplicity : a number or range that indicates how many
	 	  instances of a class are involved in the links for an association
	 	- Role : a name given to participants in an association to 
	 	  distinguish them
	 	- Qualifier : a key value used to distinguishes instances in 
	 	  a link in lieu of a large multiplicity
	 	- implementation
	 		- sometimes an association can be implemented by writing a
	 		  class whose instances are links between related classes objects
	 		- other times associations can be implemented by adding an
	 		  attribute to a class that contains a reference to another object
	 		- in all cases implementation will involve adding new fields
	 		- usually an association that has a qualifier is
	 		  implemented with a table

Writing Large Programs
	- Abstract Classes
		- most classes denote a data type 
		- an abstract type is used to denote a general catagory of
		  objects of which there are no instances
		- abstract classes are used by defining subclasses which
		  actually do have instances
		- you can add the abstract header to methods in order to make
		  sure that the inheriting classes implement the method
	- Design Patterns
		- known successful designs that can be reused in large 
		  software applications
		- Singleton : a class of which exactly one instance is 
		  required
		- Proxy : a stand in for an object which calls the objects 
		  corresponding method each time one of it's methods are invoked
		  - proxies are used cannot or should not be invoked directly
		  - if the object is on a remote machine (server), a proxy
		    can be used to take care of the network comminucation and hide the location of the object from the clients
		  - or if the object is large, a proxy can be used to ensure
		    that the object is not loaded into memory unless one of it's operations is invoked
		- Chain of Responsiblity
			- similar to proxy
			- on object delegates one or more of it's methods to
			  another object
			- difference is that a proxy forwards all method
			  invokations to the real object, while in a CoR the object may handle some methods locally, and only delegate certain methods to the next ibject in the chain
			- also CoRs are often made up of multiple linked objects
			  that jointly provide a set of methods
		- Visitor
			- in generic algorithms it is common to have a data
			  structure that needs to be traversed where each element requires some computation
			- the visitor seperates the traversal from the operation
			  performed (visitation)
			- the visitor will implement some methods to do visitation
			  on elements in the structure and the elements will invoke the visitor methods
		- Packages
			- in large programs the global namespaces become crowded
			- every global decalration outside the package is invisible
			- package declaration : specifies that all gloabl symbols 
			  within a source file belongs to a package
			  - similar to link declaration
			  - ex. 
			  	package foo 
			  	# declares the file as a package foo

			  	or 

			  	package "/usr/local/lib/icon/foo" 
			  	# specifies the package with a string filename
			- the import declaration is used to access symbols within 
			  a package
				- ex. 
					import foo
			- explicit package references
				- sometimes multiple packages may define the same symbol
				- in this case you can explicitly refernce which package 
				  you'd like to access
				  - ex. packagename1::foobar()
				  			packagename2::foobar()
				  			::foobar() # calls gloabl foobar()
				  - you can also use :: to call a global procedure from  
				    within a class that has a method with the same name
				  - ex. 
				  		class abc(x)
				  			method write()
				  				::write("abc x = ", x)
				  			end
				  		end
			- compilation order and unidep tool
				- if possible compile the package before the program that
				  uses it
				- if there are multiple source files belonging to the
				  same package, the order in whcih they are compiled is significant
				- you can use unidep to handle this confusion for you
					- usage : unidep file1.icn file2.icn file3.icn ...
					- unidep will generate a makefile that you can use to
					  compile the package







































































































			 
=======
	- Arrays
		- there are array representations in unicon that are faster than lists 
		- used for interfacing with other languages
		- arrays have a fixed size and if you change the size it becomes a list
		- lists occupy approximately twice the space that arrays do
		- to create an array
			- list(n, x) where x is an integer or real value, and n > 0
		- you can convert a list into an array if the list meets the requirements for an array
			- list(***list to be converted***)

The System Interface
	
>>>>>>> d269b5902f18023d13a413ea908e3c162ebf18b0
		

	
			
				
				  
			
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	